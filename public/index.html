<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chinese Character Mnemonics</title>


  <script src="https://unpkg.com/pinyin@2/dist/pinyin.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2563eb;
      --primary-light: #3b82f6;
      --secondary: #059669;
      --danger: #dc2626;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-500: #6b7280;
      --gray-700: #374151;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
      --radius: 8px;
    }
    body {
      font-family: 'Inter', sans-serif;
      line-height: 1.5;
      color: var(--gray-700);
      background-color: #f9fafb;
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
    }
    h1, h2, h3 {
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: 16px;
    }
    h1 {
      font-size: 28px;
      color: var(--primary);
      margin-bottom: 8px;
    }
    .subtitle {
      font-size: 16px;
      color: var(--gray-500);
      margin-bottom: 32px;
    }
    .form-section {
      background: white;
      border-radius: var(--radius);
      padding: 32px;
      box-shadow: var(--shadow-sm);
      margin-bottom: 40px;
      border: 1px solid var(--gray-200);
    }
    .input-group {
      margin-bottom: 16px;
    }
    label {
      display: block;
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 14px;
    }
    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius);
      font-family: inherit;
      transition: border 0.2s;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
.canvas-section {
  display: flex;
  flex-direction: column; /* Stack vertically on mobile */
  gap: 20px;
  margin: 24px 0;
}

@media (min-width: 768px) {
  .canvas-section {
    flex-direction: row; /* Side-by-side on desktop */
    justify-content: space-between;
  }
  
  .canvas-container {
    flex: 0 0 calc(50% - 10px); /* Equal width with gap */
  }
}

/* Ensure canvases don't overflow */
canvas {
  max-width: 100%;
  height: auto;
  display: block;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}
    .canvas-container {
      flex: 1;
    }
    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 16px;
      border-radius: var(--radius);
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    .btn-primary:hover {
      background: var(--primary-light);
    }
    .btn-secondary {
      background: white;
      color: var(--gray-700);
      border: 1px solid var(--gray-200);
    }
    .btn-secondary:hover {
      background: var(--gray-100);
    }
    .btn-danger {
      background: var(--danger);
      color: white;
    }
    .btn-danger:hover {
      opacity: 0.9;
    }
    .entries-section {
      margin-top: 40px;
    }
    .entries-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .entry-card {
      background: white;
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--gray-200);
    }
    .entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .entry-character {
      font-size: 32px;
      font-family: 'Noto Sans SC', sans-serif;
      line-height: 1;
    }
    .entry-pinyin {
      color: var(--gray-500);
      font-size: 14px;
    }
    .entry-meta {
      margin: 12px 0;
    }
    .entry-meta p {
      margin: 8px 0;
    }
    .entry-meta strong {
      font-weight: 500;
    }
    .entry-image {
      width: 100%;
      height: 120px;
      object-fit: contain;
      background: var(--gray-100);
      border-radius: 4px;
      margin-top: 12px;
    }
    .entry-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    .image-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .tool-options {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .tool-option {
      padding: 8px 12px;
      border-radius: 4px;
      background: var(--gray-100);
      cursor: pointer;
    }
    .tool-option.active {
      background: var(--primary);
      color: white;
    }
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    /* Quiz Styles */
    .quiz-section {
      margin-top: 40px;
      display: none;
    }
    .quiz-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .quiz-form {
      background: white;
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--gray-200);
    }
    .quiz-form .revealed {
      background-color: #f0fdf4;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    .quiz-form .hidden-input {
      margin-bottom: 15px;
    }
    .quiz-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    .quiz-feedback {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }
    .correct {
      background-color: #f0fdf4;
      color: #059669;
    }
    .incorrect {
      background-color: #fef2f2;
      color: #dc2626;
    }
    .quiz-progress {
      margin: 15px 0;
      display: none;
    }
    .quiz-feedback {
      display: none;
      padding: 10px;
      margin-top: 10px;
      border-radius: 4px;
    }
    .quiz-feedback.correct {
      background-color: #e6f7e6;
      color: #2e7d32;
    }
    .quiz-feedback.incorrect {
      background-color: #ffebee;
      color: #c62828;
    }
    [data-property] {
      border: 1px solid var(--gray-200);
      transition: border 0.2s;
    }
    progress {
      width: 100%;
      height: 10px;
      border-radius: 5px;
    }
    progress::-webkit-progress-bar {
      background-color: var(--gray-200);
      border-radius: 5px;
    }
    progress::-webkit-progress-value {
      background-color: var(--primary);
      border-radius: 5px;
    }
    .answer-display {
      display: none;
      margin-top: 8px;
      padding: 8px;
      background-color: #f0f0f0;
      border-radius: 4px;
      border-left: 3px solid var(--secondary);
    }
    .check-answer-btn {
      margin-top: 8px;
      padding: 6px 12px;
      background-color: var(--gray-200);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .check-answer-btn:hover {
      background-color: var(--gray-300);
    }
    .sentence-quiz-form {
      background: white;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .sentence-canvas {
      width: 100%;
      height: 200px;
      border: 1px solid #ddd;
      margin: 10px 0;
    }
    .ai-feedback {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      border-left: 3px solid #6c757d;
    }
    .hsk1-palette {
      border: 1px solid #e5e7eb;
    }
    .hsk1-palette button {
      background: #f3f4f6;
      border: none;
      border-radius: 4px;
      padding: 5px 10px;
      transition: all 0.2s;
    }
    .hsk1-palette button:hover {
      background: #2563eb;
      color: white;
    }
    .hsk1-palette h3 {
      margin-top: 0;
      font-size: 16px;
      color: #374151;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 8px;
    }

    /* Accent Popup */
    .accent-popup {
      position: absolute;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius);
      box-shadow: var(--shadow-md);
      padding: 8px;
      display: none;
      z-index: 1000;
      min-width: 200px;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 90vw;
      top: calc(100% + 4px);
      left: 0;
    }
    .accent-option {
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
      min-width: 30px;
      text-align: center;
      border: 1px solid transparent;
    }
    .accent-option:hover, .accent-option.active {
      background: var(--primary);
      color: white;
      border-color: rgba(255,255,255,0.3);
    }

    /* Character Suggestions Popup */
    .character-suggestions {
      position: absolute;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius);
      box-shadow: var(--shadow-md);
      padding: 12px;
      display: none;
      z-index: 1000;
      min-width: 300px;
      max-width: 90vw;
      top: calc(100% + 4px);
      left: 0;
      max-height: 300px;
      overflow-y: auto;
    }
    .character-suggestion {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
      border: 1px solid transparent;
      margin-bottom: 4px;
    }
    .character-suggestion:hover, .character-suggestion.active {
      background: var(--primary);
      color: white;
      border-color: rgba(255,255,255,0.3);
    }
    .character-suggestion .char {
      font-size: 24px;
      font-family: 'Noto Sans SC', sans-serif;
      margin-right: 12px;
      min-width: 30px;
    }
    .character-suggestion .pinyin {
      font-size: 14px;
      color: inherit;
      opacity: 0.9;
      margin-right: 12px;
    }
         .character-suggestion .meaning {
       font-size: 14px;
       color: inherit;
       opacity: 0.8;
       flex: 1;
     }
     
     .phrase-suggestion {
       background: var(--secondary) !important;
       color: white !important;
       border: 2px solid var(--secondary) !important;
       font-weight: 500;
     }
     
     .phrase-suggestion:hover {
       background: var(--secondary) !important;
       opacity: 0.9;
     }
    .converter-output {
      margin-top: 20px;
      padding: 16px;
      background: var(--gray-100);
      border-radius: var(--radius);
      border: 1px solid var(--gray-200);
    }
    .converter-output p {
      margin: 8px 0;
      font-size: 16px;
    }
    .converter-output span {
      font-family: 'Noto Sans SC', sans-serif;
      font-size: 18px;
      color: var(--primary);
    }
         .converter-output .pinyin-output {
       font-family: 'Inter', sans-serif;
     }
     
     .converter-actions {
       display: flex;
       gap: 8px;
       flex-wrap: wrap;
     }
     
     .converter-actions .btn {
       font-size: 14px;
       padding: 8px 12px;
     }
     
      kbd {
        background: var(--gray-200);
        border: 1px solid var(--gray-300);
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 12px;
        font-family: monospace;
      }
      
      .hint-reveal-btn {
        background: var(--secondary);
        color: white;
        border: none;
        transition: all 0.2s;
      }
      
      .hint-reveal-btn:hover {
        background: var(--secondary);
        opacity: 0.9;
        transform: translateY(-1px);
      }
      
      .hint-display {
        background: var(--gray-100);
        padding: 12px;
        border-radius: var(--radius);
        margin: 8px 0;
        border-left: 4px solid var(--secondary);
        font-style: italic;
      }
     
     .search-results {
       margin-top: 12px;
       max-height: 300px;
       overflow-y: auto;
       border: 1px solid var(--gray-200);
       border-radius: var(--radius);
       background: white;
     }
     
     .search-result-item {
       display: flex;
       align-items: center;
       padding: 12px;
       border-bottom: 1px solid var(--gray-100);
       cursor: pointer;
       transition: background 0.2s;
     }
     
     .search-result-item:hover {
       background: var(--gray-100);
     }
     
     .search-result-item:last-child {
       border-bottom: none;
     }
     
     .search-result-item .char {
       font-size: 24px;
       font-family: 'Noto Sans SC', sans-serif;
       margin-right: 16px;
       min-width: 30px;
     }
     
     .search-result-item .info {
       flex: 1;
     }
     
     .search-result-item .pinyin {
       font-size: 14px;
       color: var(--gray-500);
       margin-bottom: 4px;
     }
     
     .search-result-item .meaning {
       font-size: 14px;
       color: var(--gray-700);
     }

    @media (max-width: 768px) {
      .canvas-section {
        flex-direction: column;
        gap: 20px;
      }
      .image-grid {
        grid-template-columns: 1fr;
      }
      .quiz-controls {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Chinese Character Mnemonics</h1>
    <p class="subtitle">Learn characters through visual memory aids</p>
  </header>
  <main>
    <!-- New Pinyin to Character Converter Section -->
    <section class="form-section">
      <h2>Pinyin to Chinese Character Converter</h2>
      <div class="input-group">
        <label for="pinyin-converter-input">Type Pinyin (e.g., "ni hao")</label>
                 <div class="converter-container" style="position: relative;">
           <input type="text" id="pinyin-converter-input" placeholder="Type Pinyin continuously (e.g., nihao, woaini)..." style="font-size: 18px; padding: 15px;">
           <div id="character-suggestions" class="character-suggestions"></div>
         </div>
         <div class="input-group" style="margin-top: 16px;">
           <label for="search-input">Search Characters</label>
           <input type="text" id="search-input" placeholder="Search by meaning, pinyin, or character..." style="font-size: 16px; padding: 12px;">
           <div id="search-results" class="search-results" style="display: none;"></div>
         </div>
                 <div class="converter-output">
           <p><strong>Chinese Characters:</strong> <span id="chinese-output"></span></p>
           <p><strong>Pinyin with Tones:</strong> <span id="pinyin-output"></span></p>
           <p><strong>Meaning:</strong> <span id="meaning-output"></span></p>
           <p><strong>Character Count:</strong> <span id="char-count">0</span></p>
           <div class="converter-actions" style="margin-top: 16px;">
             <button type="button" id="convert-chinese-btn" class="btn btn-secondary" style="margin-right: 8px;">Convert Chinese â†’ Pinyin</button>
             <button type="button" id="convert-pinyin-btn" class="btn btn-secondary" style="margin-right: 8px;">Convert Pinyin â†’ Chinese</button>
             <button type="button" id="copy-results-btn" class="btn btn-secondary">ðŸ“‹ Copy Results</button>
           </div>
           <div class="converter-tips" style="margin-top: 16px; padding: 12px; background: var(--gray-100); border-radius: var(--radius); font-size: 14px; color: var(--gray-600);">
             <strong>ðŸ’¡ Tips:</strong> Type Pinyin continuously - the system will automatically detect valid Chinese word sequences and suggest characters. No need for spaces! Mix Chinese characters and Pinyin freely. Use <kbd>Ctrl+Shift+P</kbd> to quickly focus the converter.
           </div>
         </div>
      </div>
    </section>

    <section class="form-section">
      <h2>Add New Character</h2>
      <div class="input-group">
        <label for="pinyin-input">Pinyin</label>
        <div class="input-container" style="position: relative;">
          <input type="text" id="pinyin-input" placeholder="xiÅ«" required>
          <div id="accent-popup" class="accent-popup"></div>
        </div>
      </div>
      <div class="input-group">
        <label for="meaning-input">Meaning</label>
        <input type="text" id="meaning-input" placeholder="rest" required>
      </div>
      <div class="input-group">
        <label for="hint-input">Mnemonic Hint</label>
        <input type="text" id="hint-input" placeholder="e.g., 'tree + sun = rest' or any memory aid" required>
      </div>
  <div class="canvas-section">
    <!-- Character Canvas -->
    <div class="canvas-container">
      <div class="canvas-header">
        <h3>Draw Character</h3>
        <button class="btn btn-secondary" id="clear-character">Clear</button>
      </div>
      <canvas id="characterCanvas" width="400" height="300"></canvas>
    </div>
    
    <!-- Mnemonic Canvas -->
    <div class="canvas-container">
      <div class="canvas-header">
        <h3>Draw Mnemonic</h3>
        <button class="btn btn-secondary" id="clear-mnemonic">Clear</button>
      </div>
      <canvas id="mnemonicCanvas" width="400" height="300"></canvas>
    </div>
  </div>
      </div>
      <div class="input-group">
        <button type="button" id="play-pinyin" class="btn btn-secondary" style="margin-right: 8px;">ðŸ”Š Play</button>
        <button type="button" id="record-pinyin" class="btn btn-secondary">ðŸŽ¤ Record</button>
      </div>
      <div id="pronunciation-feedback" class="ai-feedback" style="display: none;">
        <p id="feedback-text"></p>
      </div>
      <button id="upload-button" class="btn btn-primary">
        <span id="button-text">Save Character</span>
      </button>
    </section>

    <section class="entries-section">
      <h2>Your Characters</h2>
      <div id="entries-container" class="entries-grid">
        <!-- Entries will be loaded here -->
      </div>
    </section>

    <!-- Quiz Section -->
    <button id="start-quiz-btn" class="btn btn-primary">Start Quiz</button>
    <section class="quiz-section">
      <h2>Test Your Knowledge</h2>
      <div class="quiz-controls">
        <button id="check-answers-btn" class="btn btn-secondary" disabled>Check Answers</button>
        <button id="reset-quiz-btn" class="btn btn-danger" disabled>Reset Quiz</button>
      </div>
      <div id="quiz-progress" class="quiz-progress">
        <progress value="0" max="100"></progress>
        <div id="progress-text" style="text-align: center; margin-top: 5px;">0% complete</div>
      </div>
      <div id="quiz-container">
        <!-- Quiz forms will be loaded here -->
      </div>
    </section>

    <button id="start-sentence-quiz-btn" class="btn btn-primary">Start Sentence Quiz</button>
    <section class="sentence-quiz-section" style="margin-top: 40px; display: none;">
      <h2>Sentence Builder</h2>
      <div class="quiz-controls">
        <select id="sentence-length">
          <option value="3">3 words</option>
          <option value="5">5 words</option>
          <option value="7">7 words</option>
          <option value="10">10 words</option>
        </select>
      </div>
      <div id="sentence-quiz-container"></div>
    </section>
  </main>

  <script>
    // ======================
    // Configuration
    // ======================
    // API keys are now handled by the backend server
    // Frontend only contains public configuration

    // ======================
    // State Management setupCanvasEvents
    // ======================
    let quizEntries = [];
    let sentenceQuizEntries = [];
    let currentQuizIndex = 0;
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let activeAccentIndex = -1;

    // Pinyin Accent Map
    const pinyinAccentMap = {
      'a': ['Ä', 'Ã¡', 'ÇŽ', 'Ã '],
      'e': ['Ä“', 'Ã©', 'Ä›', 'Ã¨'],
      'i': ['Ä«', 'Ã­', 'Ç', 'Ã¬'],
      'o': ['Å', 'Ã³', 'Ç’', 'Ã²'],
      'u': ['Å«', 'Ãº', 'Ç”', 'Ã¹'],
      'v': ['Ç–', 'Ç˜', 'Çš', 'Çœ']
    };

    // Dynamic Pinyin to Character System using pinyin library
    const pinyinToCharMap = {};
    
    // Common Chinese characters with meanings (HSK 1-3 level)
    const commonCharacters = [
      // Basic pronouns and greetings
      { char: 'ä½ ', meaning: 'you' }, { char: 'æˆ‘', meaning: 'I/me' }, { char: 'ä»–', meaning: 'he' },
      { char: 'å¥¹', meaning: 'she' }, { char: 'å¥½', meaning: 'good' }, { char: 'æ˜¯', meaning: 'to be' },
      { char: 'ä¸', meaning: 'not' }, { char: 'çš„', meaning: 'possessive' }, { char: 'äº†', meaning: 'completed' },
      
      // Numbers
      { char: 'ä¸€', meaning: 'one' }, { char: 'äºŒ', meaning: 'two' }, { char: 'ä¸‰', meaning: 'three' },
      { char: 'å››', meaning: 'four' }, { char: 'äº”', meaning: 'five' }, { char: 'å…­', meaning: 'six' },
      { char: 'ä¸ƒ', meaning: 'seven' }, { char: 'å…«', meaning: 'eight' }, { char: 'ä¹', meaning: 'nine' },
      { char: 'å', meaning: 'ten' }, { char: 'ç™¾', meaning: 'hundred' }, { char: 'åƒ', meaning: 'thousand' },
      
      // Family
      { char: 'çˆ¸', meaning: 'father' }, { char: 'å¦ˆ', meaning: 'mother' }, { char: 'å“¥', meaning: 'older brother' },
      { char: 'å§', meaning: 'older sister' }, { char: 'å¼Ÿ', meaning: 'younger brother' }, { char: 'å¦¹', meaning: 'younger sister' },
      
      // Common verbs
      { char: 'æœ‰', meaning: 'to have' }, { char: 'åœ¨', meaning: 'at/in' }, { char: 'æ¥', meaning: 'to come' },
      { char: 'åŽ»', meaning: 'to go' }, { char: 'çœ‹', meaning: 'to look' }, { char: 'å¬', meaning: 'to listen' },
      { char: 'è¯´', meaning: 'to speak' }, { char: 'è¯»', meaning: 'to read' }, { char: 'å†™', meaning: 'to write' },
      { char: 'åƒ', meaning: 'to eat' }, { char: 'å–', meaning: 'to drink' }, { char: 'ä¹°', meaning: 'to buy' },
      
      // Common nouns
      { char: 'äºº', meaning: 'person' }, { char: 'å®¶', meaning: 'home/family' }, { char: 'å­¦', meaning: 'study' },
      { char: 'å·¥', meaning: 'work' }, { char: 'é’±', meaning: 'money' }, { char: 'æ—¶', meaning: 'time' },
      { char: 'å¤©', meaning: 'sky/day' }, { char: 'å¹´', meaning: 'year' }, { char: 'æœˆ', meaning: 'month' },
      { char: 'æ—¥', meaning: 'sun/day' }, { char: 'æ°´', meaning: 'water' }, { char: 'ç«', meaning: 'fire' },
      { char: 'å±±', meaning: 'mountain' }, { char: 'å¤§', meaning: 'big' }, { char: 'å°', meaning: 'small' },
      { char: 'æ–°', meaning: 'new' }, { char: 'è€', meaning: 'old' }, { char: 'é«˜', meaning: 'tall' },
      { char: 'é•¿', meaning: 'long' }, { char: 'çŸ­', meaning: 'short' }, { char: 'å¿«', meaning: 'fast' },
      { char: 'æ…¢', meaning: 'slow' }, { char: 'çƒ­', meaning: 'hot' }, { char: 'å†·', meaning: 'cold' },
      
      // Question words
      { char: 'è°', meaning: 'who' }, { char: 'ä»€ä¹ˆ', meaning: 'what' }, { char: 'å“ª', meaning: 'which' },
      { char: 'æ€Žä¹ˆ', meaning: 'how' }, { char: 'ä¸ºä»€ä¹ˆ', meaning: 'why' }, { char: 'å¤šå°‘', meaning: 'how many' },
      
      // Colors
      { char: 'çº¢', meaning: 'red' }, { char: 'é»„', meaning: 'yellow' }, { char: 'è“', meaning: 'blue' },
      { char: 'ç»¿', meaning: 'green' }, { char: 'ç™½', meaning: 'white' }, { char: 'é»‘', meaning: 'black' },
      
      // Animals
      { char: 'çŒ«', meaning: 'cat' }, { char: 'ç‹—', meaning: 'dog' }, { char: 'é¸Ÿ', meaning: 'bird' },
      { char: 'é±¼', meaning: 'fish' }, { char: 'é©¬', meaning: 'horse' }, { char: 'ç‰›', meaning: 'cow' },
      
      // Food
      { char: 'é¥­', meaning: 'rice/meal' }, { char: 'èœ', meaning: 'vegetable' }, { char: 'è‚‰', meaning: 'meat' },
      { char: 'èŒ¶', meaning: 'tea' }, { char: 'é…’', meaning: 'wine/alcohol' }, { char: 'æ°´', meaning: 'water' },
      
      // Places
      { char: 'ä¸­', meaning: 'middle' }, { char: 'å›½', meaning: 'country' }, { char: 'åŒ—', meaning: 'north' },
      { char: 'å—', meaning: 'south' }, { char: 'ä¸œ', meaning: 'east' }, { char: 'è¥¿', meaning: 'west' },
      { char: 'ä¸Š', meaning: 'up' }, { char: 'ä¸‹', meaning: 'down' }, { char: 'å·¦', meaning: 'left' },
      { char: 'å³', meaning: 'right' }, { char: 'å‰', meaning: 'front' }, { char: 'åŽ', meaning: 'back' }
    ];
    
    // Initialize the pinyin map dynamically
    function initializePinyinMap() {
      // Check if pinyin library is available
      if (typeof pinyin === 'undefined') {
        console.log('Pinyin library not loaded, using fallback dictionary');
        loadFallbackPinyinDictionary();
        return;
      }

      commonCharacters.forEach(item => {
        try {
          // Get pinyin using the library (without tones for matching)
          const pinyinWithoutTones = pinyin(item.char, { 
            style: pinyin.STYLE_NORMAL,
            heteronym: false 
          }).join('');
          
          // Also get pinyin with tones for display
          const pinyinWithTones = pinyin(item.char, { 
            style: pinyin.STYLE_TONE,
            heteronym: false 
          }).join('');
          
          if (pinyinWithoutTones) {
            if (!pinyinToCharMap[pinyinWithoutTones]) {
              pinyinToCharMap[pinyinWithoutTones] = [];
            }
            
            pinyinToCharMap[pinyinWithoutTones].push({
              char: item.char,
              pinyin: pinyinWithTones,
              meaning: item.meaning
            });
          }
        } catch (error) {
          console.log(`Could not get pinyin for ${item.char}:`, error);
        }
      });
      
      console.log(`Initialized ${Object.keys(pinyinToCharMap).length} pinyin entries`);
    }

    // Wait for pinyin library to be available
    function waitForPinyinLibrary() {
      return new Promise((resolve) => {
        if (typeof pinyin !== 'undefined') {
          console.log('Pinyin library found immediately');
          resolve();
          return;
        }
        
        // For pinyin v2, it should load immediately, but just in case
        setTimeout(() => {
          if (typeof pinyin !== 'undefined') {
            console.log('Pinyin library loaded');
            resolve();
          } else {
            console.log('Pinyin library not loaded, using fallback');
            resolve(); // Continue with fallback
          }
        }, 100);
      });
    }

    // Fallback pinyin dictionary when library is not available
    function loadFallbackPinyinDictionary() {
      const fallbackDict = {
        'ni': [{ char: 'ä½ ', pinyin: 'nÇ', meaning: 'you' }],
        'wo': [{ char: 'æˆ‘', pinyin: 'wÇ’', meaning: 'I/me' }],
        'ta': [{ char: 'ä»–', pinyin: 'tÄ', meaning: 'he' }],
        'ta': [{ char: 'å¥¹', pinyin: 'tÄ', meaning: 'she' }],
        'hao': [{ char: 'å¥½', pinyin: 'hÇŽo', meaning: 'good' }],
        'shi': [{ char: 'æ˜¯', pinyin: 'shÃ¬', meaning: 'to be' }],
        'bu': [{ char: 'ä¸', pinyin: 'bÃ¹', meaning: 'not' }],
        'de': [{ char: 'çš„', pinyin: 'de', meaning: 'possessive' }],
        'le': [{ char: 'äº†', pinyin: 'le', meaning: 'completed' }],
        'yi': [{ char: 'ä¸€', pinyin: 'yÄ«', meaning: 'one' }],
        'er': [{ char: 'äºŒ', pinyin: 'Ã¨r', meaning: 'two' }],
        'san': [{ char: 'ä¸‰', pinyin: 'sÄn', meaning: 'three' }],
        'si': [{ char: 'å››', pinyin: 'sÃ¬', meaning: 'four' }],
        'wu': [{ char: 'äº”', pinyin: 'wÇ”', meaning: 'five' }],
        'liu': [{ char: 'å…­', pinyin: 'liÃ¹', meaning: 'six' }],
        'qi': [{ char: 'ä¸ƒ', pinyin: 'qÄ«', meaning: 'seven' }],
        'ba': [{ char: 'å…«', pinyin: 'bÄ', meaning: 'eight' }],
        'jiu': [{ char: 'ä¹', pinyin: 'jiÇ”', meaning: 'nine' }],
        'shi': [{ char: 'å', pinyin: 'shÃ­', meaning: 'ten' }],
        'bai': [{ char: 'ç™¾', pinyin: 'bÇŽi', meaning: 'hundred' }],
        'qian': [{ char: 'åƒ', pinyin: 'qiÄn', meaning: 'thousand' }],
        'ba': [{ char: 'çˆ¸', pinyin: 'bÃ ', meaning: 'father' }],
        'ma': [{ char: 'å¦ˆ', pinyin: 'mÄ', meaning: 'mother' }],
        'ge': [{ char: 'å“¥', pinyin: 'gÄ“', meaning: 'older brother' }],
        'jie': [{ char: 'å§', pinyin: 'jiÄ›', meaning: 'older sister' }],
        'di': [{ char: 'å¼Ÿ', pinyin: 'dÃ¬', meaning: 'younger brother' }],
        'mei': [{ char: 'å¦¹', pinyin: 'mÃ¨i', meaning: 'younger sister' }],
        'you': [{ char: 'æœ‰', pinyin: 'yÇ’u', meaning: 'to have' }],
        'zai': [{ char: 'åœ¨', pinyin: 'zÃ i', meaning: 'at/in' }],
        'lai': [{ char: 'æ¥', pinyin: 'lÃ¡i', meaning: 'to come' }],
        'qu': [{ char: 'åŽ»', pinyin: 'qÃ¹', meaning: 'to go' }],
        'kan': [{ char: 'çœ‹', pinyin: 'kÃ n', meaning: 'to look' }],
        'ting': [{ char: 'å¬', pinyin: 'tÄ«ng', meaning: 'to listen' }],
        'shuo': [{ char: 'è¯´', pinyin: 'shuÅ', meaning: 'to speak' }],
        'du': [{ char: 'è¯»', pinyin: 'dÃº', meaning: 'to read' }],
        'xie': [{ char: 'å†™', pinyin: 'xiÄ›', meaning: 'to write' }],
        'chi': [{ char: 'åƒ', pinyin: 'chÄ«', meaning: 'to eat' }],
        'he': [{ char: 'å–', pinyin: 'hÄ“', meaning: 'to drink' }],
        'mai': [{ char: 'ä¹°', pinyin: 'mÇŽi', meaning: 'to buy' }],
        'ren': [{ char: 'äºº', pinyin: 'rÃ©n', meaning: 'person' }],
        'jia': [{ char: 'å®¶', pinyin: 'jiÄ', meaning: 'home/family' }],
        'xue': [{ char: 'å­¦', pinyin: 'xuÃ©', meaning: 'study' }],
        'gong': [{ char: 'å·¥', pinyin: 'gÅng', meaning: 'work' }],
        'qian': [{ char: 'é’±', pinyin: 'qiÃ¡n', meaning: 'money' }],
        'shi': [{ char: 'æ—¶', pinyin: 'shÃ­', meaning: 'time' }],
        'tian': [{ char: 'å¤©', pinyin: 'tiÄn', meaning: 'sky/day' }],
        'nian': [{ char: 'å¹´', pinyin: 'niÃ¡n', meaning: 'year' }],
        'yue': [{ char: 'æœˆ', pinyin: 'yuÃ¨', meaning: 'month' }],
        'ri': [{ char: 'æ—¥', pinyin: 'rÃ¬', meaning: 'sun/day' }],
        'shui': [{ char: 'æ°´', pinyin: 'shuÇ', meaning: 'water' }],
        'huo': [{ char: 'ç«', pinyin: 'huÇ’', meaning: 'fire' }],
        'shan': [{ char: 'å±±', pinyin: 'shÄn', meaning: 'mountain' }],
        'da': [{ char: 'å¤§', pinyin: 'dÃ ', meaning: 'big' }],
        'xiao': [{ char: 'å°', pinyin: 'xiÇŽo', meaning: 'small' }],
        'xin': [{ char: 'æ–°', pinyin: 'xÄ«n', meaning: 'new' }],
        'lao': [{ char: 'è€', pinyin: 'lÇŽo', meaning: 'old' }],
        'gao': [{ char: 'é«˜', pinyin: 'gÄo', meaning: 'tall' }],
        'chang': [{ char: 'é•¿', pinyin: 'chÃ¡ng', meaning: 'long' }],
        'duan': [{ char: 'çŸ­', pinyin: 'duÇŽn', meaning: 'short' }],
        'kuai': [{ char: 'å¿«', pinyin: 'kuÃ i', meaning: 'fast' }],
        'man': [{ char: 'æ…¢', pinyin: 'mÃ n', meaning: 'slow' }],
        're': [{ char: 'çƒ­', pinyin: 'rÃ¨', meaning: 'hot' }],
        'leng': [{ char: 'å†·', pinyin: 'lÄ›ng', meaning: 'cold' }],
        'shei': [{ char: 'è°', pinyin: 'shÃ©i', meaning: 'who' }],
        'shenme': [{ char: 'ä»€ä¹ˆ', pinyin: 'shÃ©nme', meaning: 'what' }],
        'na': [{ char: 'å“ª', pinyin: 'nÇŽ', meaning: 'which' }],
        'zenme': [{ char: 'æ€Žä¹ˆ', pinyin: 'zÄ›nme', meaning: 'how' }],
        'weishenme': [{ char: 'ä¸ºä»€ä¹ˆ', pinyin: 'wÃ¨ishÃ©nme', meaning: 'why' }],
        'duoshao': [{ char: 'å¤šå°‘', pinyin: 'duÅshao', meaning: 'how many' }],
        'hong': [{ char: 'çº¢', pinyin: 'hÃ³ng', meaning: 'red' }],
        'huang': [{ char: 'é»„', pinyin: 'huÃ¡ng', meaning: 'yellow' }],
        'lan': [{ char: 'è“', pinyin: 'lÃ¡n', meaning: 'blue' }],
        'lv': [{ char: 'ç»¿', pinyin: 'lÇœ', meaning: 'green' }],
        'bai': [{ char: 'ç™½', pinyin: 'bÃ¡i', meaning: 'white' }],
        'hei': [{ char: 'é»‘', pinyin: 'hÄ“i', meaning: 'black' }],
        'mao': [{ char: 'çŒ«', pinyin: 'mÄo', meaning: 'cat' }],
        'gou': [{ char: 'ç‹—', pinyin: 'gÇ’u', meaning: 'dog' }],
        'niao': [{ char: 'é¸Ÿ', pinyin: 'niÇŽo', meaning: 'bird' }],
        'yu': [{ char: 'é±¼', pinyin: 'yÃº', meaning: 'fish' }],
        'ma': [{ char: 'é©¬', pinyin: 'mÇŽ', meaning: 'horse' }],
        'niu': [{ char: 'ç‰›', pinyin: 'niÃº', meaning: 'cow' }],
        'fan': [{ char: 'é¥­', pinyin: 'fÃ n', meaning: 'rice/meal' }],
        'cai': [{ char: 'èœ', pinyin: 'cÃ i', meaning: 'vegetable' }],
        'rou': [{ char: 'è‚‰', pinyin: 'rÃ²u', meaning: 'meat' }],
        'cha': [{ char: 'èŒ¶', pinyin: 'chÃ¡', meaning: 'tea' }],
        'jiu': [{ char: 'é…’', pinyin: 'jiÇ”', meaning: 'wine/alcohol' }],
        'shui': [{ char: 'æ°´', pinyin: 'shuÇ', meaning: 'water' }],
        'zhong': [{ char: 'ä¸­', pinyin: 'zhÅng', meaning: 'middle' }],
        'guo': [{ char: 'å›½', pinyin: 'guÃ³', meaning: 'country' }],
        'bei': [{ char: 'åŒ—', pinyin: 'bÄ›i', meaning: 'north' }],
        'nan': [{ char: 'å—', pinyin: 'nÃ¡n', meaning: 'south' }],
        'dong': [{ char: 'åŒ—', pinyin: 'dÅng', meaning: 'east' }],
        'xi': [{ char: 'è¥¿', pinyin: 'xÄ«', meaning: 'west' }],
        'shang': [{ char: 'ä¸Š', pinyin: 'shÃ ng', meaning: 'up' }],
        'xia': [{ char: 'ä¸‹', pinyin: 'xiÃ ', meaning: 'down' }],
        'zuo': [{ char: 'å·¦', pinyin: 'zuÇ’', meaning: 'left' }],
        'you': [{ char: 'å³', pinyin: 'yÃ²u', meaning: 'right' }],
        'qian': [{ char: 'å‰', pinyin: 'qiÃ¡n', meaning: 'front' }],
        'hou': [{ char: 'åŽ', pinyin: 'hÃ²u', meaning: 'back' }]
      };

      // Load fallback dictionary into pinyinToCharMap
      Object.entries(fallbackDict).forEach(([pinyinKey, chars]) => {
        pinyinToCharMap[pinyinKey] = chars;
      });

      console.log(`Loaded ${Object.keys(pinyinToCharMap).length} fallback pinyin entries`);
    }

    // Enhanced Character Database System
    let characterDatabase = new Map();
    let pinyinIndex = new Map();
    
    // Initialize with existing data
    Object.entries(pinyinToCharMap).forEach(([pinyin, chars]) => {
      pinyinIndex.set(pinyin, chars);
      chars.forEach(char => {
        characterDatabase.set(char.char, char);
      });
    });

    // Load additional character data from external sources
    async function loadExternalCharacterData() {
      try {
        // Try to load from CC-CEDICT (free Chinese-English dictionary)
        const response = await fetch('https://raw.githubusercontent.com/chanind/hanzi-writer-data/master/data/characters.json');
        if (response.ok) {
          const data = await response.json();
          Object.entries(data).forEach(([char, charData]) => {
            if (charData.pinyin && charData.definition) {
              const entry = {
                char: char,
                pinyin: charData.pinyin[0], // Take first pronunciation
                meaning: charData.definition.split(';')[0] // Take first definition
              };
              characterDatabase.set(char, entry);
              
              // Index by pinyin (without tones for matching)
              const pinyinKey = charData.pinyin[0].replace(/[ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, 
                (match) => {
                  const toneMap = { 'Ä': 'a', 'Ã¡': 'a', 'ÇŽ': 'a', 'Ã ': 'a',
                                   'Ä“': 'e', 'Ã©': 'e', 'Ä›': 'e', 'Ã¨': 'e',
                                   'Ä«': 'i', 'Ã­': 'i', 'Ç': 'i', 'Ã¬': 'i',
                                   'Å': 'o', 'Ã³': 'o', 'Ç’': 'o', 'Ã²': 'o',
                                   'Å«': 'u', 'Ãº': 'u', 'Ç”': 'u', 'Ã¹': 'u',
                                   'Ç–': 'v', 'Ç˜': 'v', 'Çš': 'v', 'Çœ': 'v' };
                  return toneMap[match] || match;
                });
              
              if (!pinyinIndex.has(pinyinKey)) {
                pinyinIndex.set(pinyinKey, []);
              }
              pinyinIndex.get(pinyinKey).push(entry);
            }
          });
          console.log(`Loaded ${characterDatabase.size} characters from external source`);
        }
      } catch (error) {
        console.log('Could not load external character data, using built-in dictionary');
        // Fallback: Load a larger built-in dictionary
        loadExtendedBuiltInDictionary();
      }
    }

    // Extended built-in dictionary with more common characters
    function loadExtendedBuiltInDictionary() {
      const extendedDict = {
        'ai': [{ char: 'çˆ±', pinyin: 'Ã i', meaning: 'love' }],
        'ba': [{ char: 'å…«', pinyin: 'bÄ', meaning: 'eight' }],
        'ba': [{ char: 'çˆ¸', pinyin: 'bÃ ', meaning: 'father' }],
        'bei': [{ char: 'åŒ—', pinyin: 'bÄ›i', meaning: 'north' }],
        'ben': [{ char: 'æœ¬', pinyin: 'bÄ›n', meaning: 'book' }],
        'bu': [{ char: 'ä¸', pinyin: 'bÃ¹', meaning: 'not' }],
        'cai': [{ char: 'èœ', pinyin: 'cÃ i', meaning: 'vegetable' }],
        'cha': [{ char: 'èŒ¶', pinyin: 'chÃ¡', meaning: 'tea' }],
        'chi': [{ char: 'åƒ', pinyin: 'chÄ«', meaning: 'eat' }],
        'da': [{ char: 'å¤§', pinyin: 'dÃ ', meaning: 'big' }],
        'de': [{ char: 'çš„', pinyin: 'de', meaning: 'possessive' }],
        'dian': [{ char: 'ç”µ', pinyin: 'diÃ n', meaning: 'electricity' }],
        'dong': [{ char: 'ä¸œ', pinyin: 'dÅng', meaning: 'east' }],
        'du': [{ char: 'è¯»', pinyin: 'dÃº', meaning: 'read' }],
        'duo': [{ char: 'å¤š', pinyin: 'duÅ', meaning: 'many' }],
        'er': [{ char: 'äºŒ', pinyin: 'Ã¨r', meaning: 'two' }],
        'fa': [{ char: 'å‘', pinyin: 'fÄ', meaning: 'send' }],
        'fei': [{ char: 'é£ž', pinyin: 'fÄ“i', meaning: 'fly' }],
        'fen': [{ char: 'åˆ†', pinyin: 'fÄ“n', meaning: 'minute' }],
        'gao': [{ char: 'é«˜', pinyin: 'gÄo', meaning: 'tall' }],
        'ge': [{ char: 'ä¸ª', pinyin: 'gÃ¨', meaning: 'measure word' }],
        'gong': [{ char: 'å·¥', pinyin: 'gÅng', meaning: 'work' }],
        'gou': [{ char: 'ç‹—', pinyin: 'gÇ’u', meaning: 'dog' }],
        'guo': [{ char: 'å›½', pinyin: 'guÃ³', meaning: 'country' }],
        'hai': [{ char: 'è¿˜', pinyin: 'hÃ¡i', meaning: 'still' }],
        'han': [{ char: 'æ±‰', pinyin: 'hÃ n', meaning: 'Chinese' }],
        'he': [{ char: 'å’Œ', pinyin: 'hÃ©', meaning: 'and' }],
        'hen': [{ char: 'å¾ˆ', pinyin: 'hÄ›n', meaning: 'very' }],
        'hou': [{ char: 'åŽ', pinyin: 'hÃ²u', meaning: 'after' }],
        'hui': [{ char: 'ä¼š', pinyin: 'huÃ¬', meaning: 'can' }],
        'ji': [{ char: 'å‡ ', pinyin: 'jÇ', meaning: 'how many' }],
        'jia': [{ char: 'å®¶', pinyin: 'jiÄ', meaning: 'home' }],
        'jian': [{ char: 'è§', pinyin: 'jiÃ n', meaning: 'see' }],
        'jiao': [{ char: 'å«', pinyin: 'jiÃ o', meaning: 'call' }],
        'jin': [{ char: 'ä»Š', pinyin: 'jÄ«n', meaning: 'today' }],
        'jiu': [{ char: 'ä¹', pinyin: 'jiÇ”', meaning: 'nine' }],
        'kai': [{ char: 'å¼€', pinyin: 'kÄi', meaning: 'open' }],
        'kan': [{ char: 'çœ‹', pinyin: 'kÃ n', meaning: 'look' }],
        'ke': [{ char: 'å¯', pinyin: 'kÄ›', meaning: 'can' }],
        'lai': [{ char: 'æ¥', pinyin: 'lÃ¡i', meaning: 'come' }],
        'lao': [{ char: 'è€', pinyin: 'lÇŽo', meaning: 'old' }],
        'le': [{ char: 'äº†', pinyin: 'le', meaning: 'completed' }],
        'li': [{ char: 'é‡Œ', pinyin: 'lÇ', meaning: 'inside' }],
        'liu': [{ char: 'å…­', pinyin: 'liÃ¹', meaning: 'six' }],
        'ma': [{ char: 'å¦ˆ', pinyin: 'mÄ', meaning: 'mother' }],
        'mai': [{ char: 'ä¹°', pinyin: 'mÇŽi', meaning: 'buy' }],
        'mao': [{ char: 'çŒ«', pinyin: 'mÄo', meaning: 'cat' }],
        'mei': [{ char: 'æ²¡', pinyin: 'mÃ©i', meaning: 'not have' }],
        'ming': [{ char: 'å', pinyin: 'mÃ­ng', meaning: 'name' }],
        'na': [{ char: 'é‚£', pinyin: 'nÃ ', meaning: 'that' }],
        'ne': [{ char: 'å‘¢', pinyin: 'ne', meaning: 'question particle' }],
        'neng': [{ char: 'èƒ½', pinyin: 'nÃ©ng', meaning: 'can' }],
        'nian': [{ char: 'å¹´', pinyin: 'niÃ¡n', meaning: 'year' }],
        'nv': [{ char: 'å¥³', pinyin: 'nÇš', meaning: 'female' }],
        'peng': [{ char: 'æœ‹', pinyin: 'pÃ©ng', meaning: 'friend' }],
        'piao': [{ char: 'æ¼‚', pinyin: 'piÃ o', meaning: 'beautiful' }],
        'ping': [{ char: 'å¹³', pinyin: 'pÃ­ng', meaning: 'flat' }],
        'qi': [{ char: 'ä¸ƒ', pinyin: 'qÄ«', meaning: 'seven' }],
        'qian': [{ char: 'å‰', pinyin: 'qiÃ¡n', meaning: 'front' }],
        'qing': [{ char: 'è¯·', pinyin: 'qÇng', meaning: 'please' }],
        'qu': [{ char: 'åŽ»', pinyin: 'qÃ¹', meaning: 'go' }],
        'ren': [{ char: 'äºº', pinyin: 'rÃ©n', meaning: 'person' }],
        'ri': [{ char: 'æ—¥', pinyin: 'rÃ¬', meaning: 'sun' }],
        'san': [{ char: 'ä¸‰', pinyin: 'sÄn', meaning: 'three' }],
        'shang': [{ char: 'ä¸Š', pinyin: 'shÃ ng', meaning: 'up' }],
        'shao': [{ char: 'å°‘', pinyin: 'shÇŽo', meaning: 'few' }],
        'shei': [{ char: 'è°', pinyin: 'shÃ©i', meaning: 'who' }],
        'shen': [{ char: 'ä»€', pinyin: 'shÃ©n', meaning: 'what' }],
        'shi': [{ char: 'å', pinyin: 'shÃ­', meaning: 'ten' }],
        'shui': [{ char: 'æ°´', pinyin: 'shuÇ', meaning: 'water' }],
        'shuo': [{ char: 'è¯´', pinyin: 'shuÅ', meaning: 'speak' }],
        'si': [{ char: 'å››', pinyin: 'sÃ¬', meaning: 'four' }],
        'suo': [{ char: 'æ‰€', pinyin: 'suÇ’', meaning: 'place' }],
        'ta': [{ char: 'ä»–', pinyin: 'tÄ', meaning: 'he' }],
        'tai': [{ char: 'å¤ª', pinyin: 'tÃ i', meaning: 'too' }],
        'tian': [{ char: 'å¤©', pinyin: 'tiÄn', meaning: 'sky' }],
        'ting': [{ char: 'å¬', pinyin: 'tÄ«ng', meaning: 'listen' }],
        'tong': [{ char: 'åŒ', pinyin: 'tÃ³ng', meaning: 'same' }],
        'wei': [{ char: 'ä¸º', pinyin: 'wÃ¨i', meaning: 'for' }],
        'wo': [{ char: 'æˆ‘', pinyin: 'wÇ’', meaning: 'I' }],
        'wu': [{ char: 'äº”', pinyin: 'wÇ”', meaning: 'five' }],
        'xi': [{ char: 'è¥¿', pinyin: 'xÄ«', meaning: 'west' }],
        'xia': [{ char: 'ä¸‹', pinyin: 'xiÃ ', meaning: 'down' }],
        'xian': [{ char: 'å…ˆ', pinyin: 'xiÄn', meaning: 'first' }],
        'xiang': [{ char: 'æƒ³', pinyin: 'xiÇŽng', meaning: 'think' }],
        'xiao': [{ char: 'å°', pinyin: 'xiÇŽo', meaning: 'small' }],
        'xie': [{ char: 'å†™', pinyin: 'xiÄ›', meaning: 'write' }],
        'xing': [{ char: 'è¡Œ', pinyin: 'xÃ­ng', meaning: 'walk' }],
        'xue': [{ char: 'å­¦', pinyin: 'xuÃ©', meaning: 'study' }],
        'ya': [{ char: 'å‘€', pinyin: 'ya', meaning: 'exclamation' }],
        'yi': [{ char: 'ä¸€', pinyin: 'yÄ«', meaning: 'one' }],
        'you': [{ char: 'æœ‰', pinyin: 'yÇ’u', meaning: 'have' }],
        'yu': [{ char: 'è¯­', pinyin: 'yÇ”', meaning: 'language' }],
        'yuan': [{ char: 'å…ƒ', pinyin: 'yuÃ¡n', meaning: 'yuan' }],
        'zai': [{ char: 'åœ¨', pinyin: 'zÃ i', meaning: 'at' }],
        'zen': [{ char: 'æ€Ž', pinyin: 'zÄ›n', meaning: 'how' }],
        'zhe': [{ char: 'è¿™', pinyin: 'zhÃ¨', meaning: 'this' }],
        'zhong': [{ char: 'ä¸­', pinyin: 'zhÅng', meaning: 'middle' }],
        'zhu': [{ char: 'ä½', pinyin: 'zhÃ¹', meaning: 'live' }],
        'zuo': [{ char: 'å', pinyin: 'zuÃ²', meaning: 'sit' }]
      };

      Object.entries(extendedDict).forEach(([pinyin, chars]) => {
        if (!pinyinIndex.has(pinyin)) {
          pinyinIndex.set(pinyin, []);
        }
        pinyinIndex.get(pinyin).push(...chars);
        chars.forEach(char => {
          characterDatabase.set(char.char, char);
        });
      });
    }

    // Enhanced character search with fuzzy matching
    function searchCharacters(query) {
      const results = [];
      const queryLower = query.toLowerCase();
      
      // Search by pinyin
      for (const [pinyin, chars] of pinyinIndex) {
        if (pinyin.includes(queryLower) || queryLower.includes(pinyin)) {
          results.push(...chars);
        }
      }
      
      // Search by meaning
      for (const char of characterDatabase.values()) {
        if (char.meaning.toLowerCase().includes(queryLower)) {
          if (!results.find(r => r.char === char.char)) {
            results.push(char);
          }
        }
      }
      
      // Search by character
      if (/[\u4e00-\u9fff]/.test(query)) {
        for (const char of query) {
          const found = characterDatabase.get(char);
          if (found && !results.find(r => r.char === found.char)) {
            results.push(found);
          }
        }
      }
      
      return results.slice(0, 20); // Limit results
    }

    // ======================
    // DOM Ready & Init
    // ======================
    document.addEventListener('DOMContentLoaded', function() {
      // Supabase client is now handled by the backend API
      setupCanvas(document.getElementById('characterCanvas'));
      setupCanvas(document.getElementById('mnemonicCanvas'));
      
      initApp();
    });

    function initApp() {
      initCanvases();
      setupCanvasEvents();
      loadCharacters();
      initQuizSystem();
      initSentenceQuiz();
      initHSK1Characters();
      setupQuizToggles();
      setupPinyinAccents();
      setupPinyinConverter();
          // Wait for pinyin library to load before initializing
    waitForPinyinLibrary().then(() => {
      initializePinyinMap();
    });
      window.speechSynthesis.getVoices(); // Load voices
      document.getElementById('upload-button').addEventListener('click', function() {
  console.log('Save button clicked!'); // Debug line
  saveCharacter();
});
    }
function setStrokeWidth(ctx, canvas) {
  const baseWidth = 4;
  const scale = window.innerWidth > 768 ? 1 : 0.7;
  ctx.lineWidth = baseWidth * scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}
    // ======================
    // Pinyin Accents initCanvas
    // ======================
    function setupPinyinAccents() {
      const pinyinInput = document.getElementById('pinyin-input');
      if (!pinyinInput) return;
      pinyinInput.addEventListener('keydown', handlePinyinAccentSuggestion);
      document.addEventListener('keydown', handlePopupNavigation);
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.input-container')) hideAccentPopup();
        if (e.target.classList.contains('accent-option')) {
          replaceLastCharacter(e.target.textContent);
          hideAccentPopup();
        }
      });
      
      // Add keyboard shortcut for converter (Ctrl+Shift+P)
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'P') {
          e.preventDefault();
          const converterInput = document.getElementById('pinyin-converter-input');
          if (converterInput) {
            converterInput.focus();
          }
        }
      });
    }
//setupCanvas
function setupCanvas(canvas) {
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  // Set internal canvas size to match display Ã— DPI
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;

  // Scale context to make drawing coordinates match CSS pixels
  ctx.scale(dpr, dpr);

  // Reset style
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4; // Thicker base stroke (will scale with DPI)

  // Clear and reset background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
// Call this after DOM loads setupCanvasEvents

    function handlePinyinAccentSuggestion(e) {
      if (e.key.length !== 1) return;
      const baseChar = e.key.toLowerCase();
      if (baseChar in pinyinAccentMap) {
        setTimeout(() => {
          const input = e.target;
          const cursorPos = input.selectionStart;
          const charBefore = input.value.charAt(cursorPos - 1).toLowerCase();
          if (charBefore === baseChar) {
            showAccentPopup(input, pinyinAccentMap[baseChar], cursorPos);
          }
        }, 0);
      }
    }

    function showAccentPopup(input, options, cursorPos) {
      const rect = input.getBoundingClientRect();
      document.getElementById('accent-popup').style.left = '0';
      document.getElementById('accent-popup').style.top = `${input.offsetHeight}px`;
      document.getElementById('accent-popup').style.display = 'flex';
      document.getElementById('accent-popup').innerHTML = '';
      options.forEach((opt, i) => {
        const el = document.createElement('div');
        el.className = 'accent-option';
        el.textContent = opt;
        el.dataset.index = i;
        document.getElementById('accent-popup').appendChild(el);
      });
      activeAccentIndex = 0;
      updateActiveAccentOption();
    }

    function updateActiveAccentOption() {
      document.querySelectorAll('.accent-option').forEach((el, i) => {
        el.classList.toggle('active', i === activeAccentIndex);
      });
    }

    function handlePopupNavigation(e) {
      if (document.getElementById('accent-popup').style.display !== 'flex') return;
      const opts = document.querySelectorAll('.accent-option');
      switch (e.key) {
        case 'ArrowRight':
        case 'ArrowDown':
          e.preventDefault();
          activeAccentIndex = (activeAccentIndex + 1) % opts.length;
          updateActiveAccentOption();
          break;
        case 'ArrowLeft':
        case 'ArrowUp':
          e.preventDefault();
          activeAccentIndex = (activeAccentIndex - 1 + opts.length) % opts.length;
          updateActiveAccentOption();
          break;
        case 'Enter':
          e.preventDefault();
          if (activeAccentIndex >= 0 && opts[activeAccentIndex]) {
            replaceLastCharacter(opts[activeAccentIndex].textContent);
            hideAccentPopup();
          }
          break;
        case 'Escape':
          e.preventDefault();
          hideAccentPopup();
          break;
      }
    }

    function hideAccentPopup() {
      document.getElementById('accent-popup').style.display = 'none';
      activeAccentIndex = -1;
    }

    function replaceLastCharacter(char) {
      const input = document.getElementById('pinyin-input');
      const pos = input.selectionStart;
      const val = input.value;
      input.value = val.substring(0, pos - 1) + char + val.substring(pos);
      input.setSelectionRange(pos, pos);
      input.dispatchEvent(new Event('input'));
    }

    // ======================
    // Pinyin to Character Converter
    // ======================
    function setupPinyinConverter() {
      const converterInput = document.getElementById('pinyin-converter-input');
      if (!converterInput) return;
      
      let currentBuffer = '';
      let suggestions = [];
      let activeSuggestionIndex = -1;
      
      converterInput.addEventListener('input', handlePinyinInput);
      converterInput.addEventListener('keydown', handleConverterKeydown);
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.converter-container')) hideCharacterSuggestions();
        if (!e.target.closest('.input-group')) {
          document.getElementById('search-results').style.display = 'none';
        }
      });
      
      // Add event listeners for conversion buttons
      document.getElementById('convert-chinese-btn').addEventListener('click', () => {
        const chineseText = document.getElementById('chinese-output').textContent;
        if (chineseText && chineseText !== '') {
          const pinyinResult = chineseToPinyin(chineseText);
          document.getElementById('pinyin-output').textContent = pinyinResult;
        }
      });
      
      document.getElementById('convert-pinyin-btn').addEventListener('click', () => {
        const pinyinText = document.getElementById('pinyin-output').textContent;
        if (pinyinText && pinyinText !== '') {
          const chineseResult = pinyinToChinese(pinyinText);
          document.getElementById('chinese-output').textContent = chineseResult;
        }
      });
      
      document.getElementById('copy-results-btn').addEventListener('click', () => {
        const chineseText = document.getElementById('chinese-output').textContent;
        const pinyinText = document.getElementById('pinyin-output').textContent;
        const meaningText = document.getElementById('meaning-output').textContent;
        
        const results = `Chinese: ${chineseText}\nPinyin: ${pinyinText}\nMeaning: ${meaningText}`;
        
        navigator.clipboard.writeText(results).then(() => {
          const originalText = document.getElementById('copy-results-btn').textContent;
          document.getElementById('copy-results-btn').textContent = 'âœ… Copied!';
          setTimeout(() => {
            document.getElementById('copy-results-btn').textContent = originalText;
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy:', err);
          alert('Failed to copy to clipboard');
        });
      });
      
      // Add search functionality
      const searchInput = document.getElementById('search-input');
      if (searchInput) {
        searchInput.addEventListener('input', handleSearch);
      }
    }
    
    // Handle character search
    function handleSearch(e) {
      const query = e.target.value.trim();
      const searchResults = document.getElementById('search-results');
      
      if (query.length < 2) {
        searchResults.style.display = 'none';
        return;
      }
      
      const results = searchCharacters(query);
      displaySearchResults(results);
    }
    
    // Display search results
    function displaySearchResults(results) {
      const searchResults = document.getElementById('search-results');
      
      if (results.length === 0) {
        searchResults.innerHTML = '<div style="padding: 16px; text-align: center; color: var(--gray-500);">No results found</div>';
        searchResults.style.display = 'block';
        return;
      }
      
      searchResults.innerHTML = '';
      results.forEach(item => {
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        resultItem.innerHTML = `
          <span class="char">${item.char}</span>
          <div class="info">
            <div class="pinyin">${item.pinyin}</div>
            <div class="meaning">${item.meaning}</div>
          </div>
        `;
        resultItem.addEventListener('click', () => {
          // Add to converter input
          const converterInput = document.getElementById('pinyin-converter-input');
          const currentValue = converterInput.value.trim();
          const newValue = currentValue ? `${currentValue} ${item.char}` : item.char;
          converterInput.value = newValue;
          converterInput.dispatchEvent(new Event('input'));
          
          // Hide search results
          searchResults.style.display = 'none';
          document.getElementById('search-input').value = '';
        });
        searchResults.appendChild(resultItem);
      });
      
      searchResults.style.display = 'block';
    }

    function handlePinyinInput(e) {
      const input = e.target;
      const value = input.value.toLowerCase().trim();
      
      // Continuous buffering approach - no space dependency
      // The buffer contains all characters since the last Chinese character
      let buffer = '';
      let lastChineseIndex = -1;
      
      // Find the last Chinese character in the input
      for (let i = value.length - 1; i >= 0; i--) {
        if (/[\u4e00-\u9fff]/.test(value[i])) {
          lastChineseIndex = i;
          break;
        }
      }
      
      // Buffer contains everything after the last Chinese character
      if (lastChineseIndex >= 0) {
        buffer = value.substring(lastChineseIndex + 1);
      } else {
        buffer = value;
      }
      
      currentBuffer = buffer;
      
      // Show suggestions for the current buffer if it's long enough
      if (currentBuffer.length >= 1) {
        showCharacterSuggestions(currentBuffer);
      } else {
        hideCharacterSuggestions();
      }
      
      // Also try to find multi-character matches in the buffer
      if (currentBuffer.length >= 2) {
        const multiCharMatch = findMultiCharacterMatch([currentBuffer]);
        if (multiCharMatch) {
          showMultiCharacterSuggestion(multiCharMatch);
        }
      }
      
      updateOutput(value);
    }
    
    // Find multi-character matches
    function findMultiCharacterMatch(syllables) {
      const cleanSyllables = syllables.map(s => s.replace(/[ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, 
        (match) => {
          const toneMap = { 'Ä': 'a', 'Ã¡': 'a', 'ÇŽ': 'a', 'Ã ': 'a',
                           'Ä“': 'e', 'Ã©': 'e', 'Ä›': 'e', 'Ã¨': 'e',
                           'Ä«': 'i', 'Ã­': 'i', 'Ç': 'i', 'Ã¬': 'i',
                           'Å': 'o', 'Ã³': 'o', 'Ç’': 'o', 'Ã²': 'o',
                           'Å«': 'u', 'Ãº': 'u', 'Ç”': 'u', 'Ã¹': 'u',
                           'Ç–': 'v', 'Ç˜': 'v', 'Çš': 'v', 'Çœ': 'v' };
          return toneMap[match] || match;
        }));
      
      // Look for common phrases in the buffer
      const phrase = cleanSyllables.join('');
      const commonPhrases = {
        'nihao': { chars: 'ä½ å¥½', pinyin: 'nÇ hÇŽo', meaning: 'hello' },
        'zaijian': { chars: 'å†è§', pinyin: 'zÃ i jiÃ n', meaning: 'goodbye' },
        'xiexie': { chars: 'è°¢è°¢', pinyin: 'xiÃ¨ xie', meaning: 'thank you' },
        'duibuqi': { chars: 'å¯¹ä¸èµ·', pinyin: 'duÃ¬ bu qÇ', meaning: 'sorry' },
        'meiguanxi': { chars: 'æ²¡å…³ç³»', pinyin: 'mÃ©i guÄn xi', meaning: "it doesn't matter" },
        'bukeqi': { chars: 'ä¸å®¢æ°”', pinyin: 'bÃ¹ kÃ¨ qi', meaning: "you're welcome" },
        'zaoshang': { chars: 'æ—©ä¸Š', pinyin: 'zÇŽo shang', meaning: 'morning' },
        'wanshang': { chars: 'æ™šä¸Š', pinyin: 'wÇŽn shang', meaning: 'evening' },
        'xianzai': { chars: 'çŽ°åœ¨', pinyin: 'xiÃ n zÃ i', meaning: 'now' },
        'mingtian': { chars: 'æ˜Žå¤©', pinyin: 'mÃ­ng tiÄn', meaning: 'tomorrow' },
        'zuotian': { chars: 'æ˜¨å¤©', pinyin: 'zuÃ³ tiÄn', meaning: 'yesterday' },
        'jintian': { chars: 'ä»Šå¤©', pinyin: 'jÄ«n tiÄn', meaning: 'today' },
        'woaini': { chars: 'æˆ‘çˆ±ä½ ', pinyin: 'wÇ’ Ã i nÇ', meaning: 'I love you' },
        'xiexieni': { chars: 'è°¢è°¢ä½ ', pinyin: 'xiÃ¨ xie nÇ', meaning: 'thank you' },
        'zaoshanghao': { chars: 'æ—©ä¸Šå¥½', pinyin: 'zÇŽo shang hÇŽo', meaning: 'good morning' },
        'wanshanghao': { chars: 'æ™šä¸Šå¥½', pinyin: 'wÇŽn shang hÇŽo', meaning: 'good evening' },
        'zaoshanghao': { chars: 'æ—©ä¸Šå¥½', pinyin: 'zÇŽo shang hÇŽo', meaning: 'good morning' },
        'wanshanghao': { chars: 'æ™šä¸Šå¥½', pinyin: 'wÇŽn shang hÇŽo', meaning: 'good evening' }
      };
      
      return commonPhrases[phrase];
    }
    
    // Show multi-character suggestion
    function showMultiCharacterSuggestion(phrase) {
      const popup = document.getElementById('character-suggestions');
      const existingContent = popup.innerHTML;
      
      // Add the phrase suggestion at the top
      const phraseSuggestion = document.createElement('div');
      phraseSuggestion.className = 'character-suggestion phrase-suggestion';
      phraseSuggestion.style.background = 'var(--secondary)';
      phraseSuggestion.style.color = 'white';
      phraseSuggestion.style.border = '2px solid var(--secondary)';
      phraseSuggestion.innerHTML = `
        <span class="char">${phrase.chars}</span>
        <span class="pinyin">${phrase.pinyin}</span>
        <span class="meaning">${phrase.meaning} (phrase)</span>
      `;
      phraseSuggestion.addEventListener('click', () => {
        // Replace the entire input with the phrase
        const input = document.getElementById('pinyin-converter-input');
        input.value = phrase.chars;
        input.dispatchEvent(new Event('input'));
        hideCharacterSuggestions();
      });
      
      // Insert at the beginning
      popup.insertBefore(phraseSuggestion, popup.firstChild);
    }

    function showCharacterSuggestions(pinyin) {
      let suggestions = pinyinToCharMap[pinyin] || [];
      
      // If no exact match, try fuzzy matching
      if (suggestions.length === 0) {
        suggestions = searchCharactersByPinyin(pinyin);
      }
      
      const popup = document.getElementById('character-suggestions');
      
      if (suggestions.length === 0) {
        hideCharacterSuggestions();
        return;
      }
      
      popup.innerHTML = '';
      suggestions.forEach((item, index) => {
        const el = document.createElement('div');
        el.className = 'character-suggestion';
        el.dataset.index = index;
        el.innerHTML = `
          <span class="char">${item.char}</span>
          <span class="pinyin">${item.pinyin}</span>
          <span class="meaning">${item.meaning}</span>
        `;
        el.addEventListener('click', () => selectCharacter(item));
        popup.appendChild(el);
      });
      
      popup.style.display = 'block';
      activeSuggestionIndex = 0;
      updateActiveSuggestion();
    }
    
    // Enhanced search function using pinyin library
    function searchCharactersByPinyin(query) {
      const results = [];
      const queryLower = query.toLowerCase();
      
      // Check if pinyin library is available
      if (typeof pinyin === 'undefined') {
        // Fallback: search through existing pinyinToCharMap
        Object.entries(pinyinToCharMap).forEach(([pinyinKey, chars]) => {
          if (pinyinKey.includes(queryLower)) {
            results.push(...chars);
          }
        });
        return results.slice(0, 10);
      }
      
      // Search through all characters in our database
      commonCharacters.forEach(char => {
        try {
          // Get pinyin without tones for matching
          const pinyinWithoutTones = pinyin(char.char, { 
            style: 'normal',
            heteronym: false 
          }).join('').toLowerCase();
          
          // Get pinyin with tones for display
          const pinyinWithTones = pinyin(char.char, { 
            style: pinyin.STYLE_TONE,
            heteronym: false 
          }).join('');
          
          // Check if query matches pinyin (partial match)
          if (pinyinWithoutTones.includes(queryLower) || queryLower.includes(pinyinWithoutTones)) {
            results.push({
              char: char.char,
              pinyin: pinyinWithTones,
              meaning: char.meaning
            });
          }
        } catch (error) {
          // Skip characters that can't be converted
        }
      });
      
      // Sort by relevance (exact matches first, then partial matches)
      results.sort((a, b) => {
        const aExact = a.pinyin.toLowerCase().replace(/[ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, '') === queryLower;
        const bExact = b.pinyin.toLowerCase().replace(/[ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, '') === queryLower;
        
        if (aExact && !bExact) return -1;
        if (!aExact && bExact) return 1;
        return 0;
      });
      
      return results.slice(0, 10); // Limit results
    }

    function hideCharacterSuggestions() {
      document.getElementById('character-suggestions').style.display = 'none';
      activeSuggestionIndex = -1;
    }

    function updateActiveSuggestion() {
      document.querySelectorAll('.character-suggestion').forEach((el, i) => {
        el.classList.toggle('active', i === activeSuggestionIndex);
      });
    }

    function handleConverterKeydown(e) {
      const popup = document.getElementById('character-suggestions');
      if (popup.style.display !== 'block') return;
      
      const suggestions = document.querySelectorAll('.character-suggestion');
      
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          activeSuggestionIndex = (activeSuggestionIndex + 1) % suggestions.length;
          updateActiveSuggestion();
          break;
        case 'ArrowUp':
          e.preventDefault();
          activeSuggestionIndex = (activeSuggestionIndex - 1 + suggestions.length) % suggestions.length;
          updateActiveSuggestion();
          break;
        case 'Enter':
          e.preventDefault();
          if (activeSuggestionIndex >= 0 && suggestions[activeSuggestionIndex]) {
            const char = suggestions[activeSuggestionIndex].querySelector('.char').textContent;
            const pinyin = suggestions[activeSuggestionIndex].querySelector('.pinyin').textContent;
            const meaning = suggestions[activeSuggestionIndex].querySelector('.meaning').textContent;
            selectCharacter({ char, pinyin, meaning });
          }
          break;
        case 'Escape':
          e.preventDefault();
          hideCharacterSuggestions();
          break;
        case 'Tab':
          e.preventDefault();
          if (activeSuggestionIndex >= 0 && suggestions[activeSuggestionIndex]) {
            const char = suggestions[activeSuggestionIndex].querySelector('.char').textContent;
            const pinyin = suggestions[activeSuggestionIndex].querySelector('.pinyin').textContent;
            const meaning = suggestions[activeSuggestionIndex].querySelector('.meaning').textContent;
            selectCharacter({ char, pinyin, meaning });
          }
          break;
      }
    }

    function selectCharacter(item) {
      const input = document.getElementById('pinyin-converter-input');
      const value = input.value;
      
      // Find the last Chinese character position
      let lastChineseIndex = -1;
      for (let i = value.length - 1; i >= 0; i--) {
        if (/[\u4e00-\u9fff]/.test(value[i])) {
          lastChineseIndex = i;
          break;
        }
      }
      
      // Replace the buffer (everything after the last Chinese character) with the selected character
      let newValue;
      if (lastChineseIndex >= 0) {
        newValue = value.substring(0, lastChineseIndex + 1) + item.char;
      } else {
        newValue = item.char;
      }
      
      input.value = newValue;
      hideCharacterSuggestions();
      updateOutput(newValue);
    }

    function updateOutput(value) {
      const chineseOutput = document.getElementById('chinese-output');
      const pinyinOutput = document.getElementById('pinyin-output');
      const meaningOutput = document.getElementById('meaning-output');
      
      // Parse the mixed Chinese and Pinyin input
      const chineseChars = [];
      const pinyinWithTones = [];
      const meanings = [];
      
      let currentPinyin = '';
      let i = 0;
      
      while (i < value.length) {
        const char = value[i];
        
        if (/[\u4e00-\u9fff]/.test(char)) {
          // It's a Chinese character
          if (currentPinyin) {
            // Add any pending Pinyin as a placeholder
            chineseChars.push('?');
            pinyinWithTones.push(currentPinyin);
            meanings.push('Type more to see suggestions');
            currentPinyin = '';
          }
          
          chineseChars.push(char);
          
          // Use pinyin library to get pronunciation
          try {
            if (typeof pinyin !== 'undefined') {
              const pinyinResult = pinyin(char, { 
                style: pinyin.STYLE_TONE,
                heteronym: false 
              }).join('');
              pinyinWithTones.push(pinyinResult);
            } else {
              pinyinWithTones.push('?');
            }
          } catch (error) {
            pinyinWithTones.push('?');
          }
          
          // Find the meaning for this character
          const found = Object.values(pinyinToCharMap).flat().find(item => item.char === char);
          if (found) {
            meanings.push(found.meaning);
          } else {
            // Try to find in common characters
            const commonChar = commonCharacters.find(c => c.char === char);
            meanings.push(commonChar ? commonChar.meaning : 'Unknown');
          }
        } else {
          // It's Pinyin, accumulate it
          currentPinyin += char;
        }
        i++;
      }
      
      // Handle any remaining Pinyin at the end
      if (currentPinyin) {
        chineseChars.push('?');
        pinyinWithTones.push(currentPinyin);
        meanings.push('Type more to see suggestions');
      }
      
      chineseOutput.textContent = chineseChars.join(' ');
      pinyinOutput.textContent = pinyinWithTones.join(' ');
      meaningOutput.textContent = meanings.join(', ');
      
      // Update character count
      const charCount = chineseChars.filter(char => char !== '?' && char !== '').length;
      document.getElementById('char-count').textContent = charCount;
    }

    // ======================
    // Chinese â†” Pinyin Conversion
    // ======================
    
    // Convert Chinese text to Pinyin
    function chineseToPinyin(text) {
      try {
        if (typeof pinyin === 'undefined') {
          console.log('Pinyin library not available, returning text');
          return text;
        }
        return pinyin(text, { 
          style: pinyin.STYLE_TONE,
          heteronym: false 
        }).join(' ');
      } catch (error) {
        console.error('Error converting Chinese to Pinyin:', error);
        return text;
      }
    }
    
    // Convert Pinyin to Chinese (find matching characters)
    function pinyinToChinese(pinyinText) {
      const results = [];
      const syllables = pinyinText.toLowerCase().split(/\s+/);
      
      syllables.forEach(syllable => {
        const cleanSyllable = syllable.replace(/[ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, 
          (match) => {
            const toneMap = { 'Ä': 'a', 'Ã¡': 'a', 'ÇŽ': 'a', 'Ã ': 'a',
                             'Ä“': 'e', 'Ã©': 'e', 'Ä›': 'e', 'Ã¨': 'e',
                             'Ä«': 'i', 'Ã­': 'i', 'Ç': 'i', 'Ã¬': 'i',
                             'Å': 'o', 'Ã³': 'o', 'Ç’': 'o', 'Ã²': 'o',
                             'Å«': 'u', 'Ãº': 'u', 'Ç”': 'u', 'Ã¹': 'u',
                             'Ç–': 'v', 'Ç˜': 'v', 'Çš': 'v', 'Çœ': 'v' };
            return toneMap[match] || match;
          });
        
        const suggestions = pinyinToCharMap[cleanSyllable] || [];
        if (suggestions.length > 0) {
          results.push(suggestions[0].char); // Take first suggestion
        } else {
          results.push('?');
        }
      });
      
      return results.join('');
    }
    
    // ======================
    // Text-to-Speech
    // ======================
    function playChinese(text, fallbackPinyin = '') {
      window.speechSynthesis.cancel();
      const utteranceText = text.trim() || fallbackPinyin;
      if (!utteranceText) return;
      const utterance = new SpeechSynthesisUtterance(utteranceText);
      utterance.lang = 'zh-CN';
      utterance.rate = 0.9;
      utterance.pitch = 1;
      const voices = window.speechSynthesis.getVoices();
      const chineseVoice = voices.find(v => v.lang.startsWith('zh'));
      if (chineseVoice) utterance.voice = chineseVoice;
      window.speechSynthesis.speak(utterance);
    }

    document.getElementById('play-pinyin').addEventListener('click', () => {
      const pinyin = document.getElementById('pinyin-input').value.trim();
      playChinese('', pinyin);
    });

    // ======================
    // Record & Evaluate
    // ======================
    document.getElementById('record-pinyin').addEventListener('click', async () => {
      const feedbackEl = document.getElementById('pronunciation-feedback');
      const feedbackText = document.getElementById('feedback-text');
      const pinyin = document.getElementById('pinyin-input').value.trim();

      if (!pinyin) {
        alert('Please enter Pinyin first.');
        return;
      }

      if (isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        document.getElementById('record-pinyin').textContent = 'ðŸŽ¤';
        document.getElementById('record-pinyin').classList.remove('btn-primary');
        document.getElementById('record-pinyin').classList.add('btn-secondary');
        feedbackText.textContent = 'Processing...';
        feedbackEl.style.display = 'block';
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);

        mediaRecorder.onstop = async () => {
          stream.getTracks().forEach(t => t.stop());
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const base64Audio = await blobToBase64(audioBlob);
          const feedback = await evaluatePronunciation(base64Audio, pinyin);
          feedbackText.innerHTML = feedback;
          feedbackEl.style.display = 'block';
        };

        mediaRecorder.start();
        isRecording = true;
        document.getElementById('record-pinyin').textContent = 'ðŸ›‘';
        document.getElementById('record-pinyin').classList.remove('btn-secondary');
        document.getElementById('record-pinyin').classList.add('btn-primary');
        feedbackText.textContent = 'Recording... Speak now!';
        feedbackEl.style.display = 'block';

      } catch (err) {
        console.error('Microphone error:', err);
        alert('Microphone access denied or not supported.');
        feedbackText.textContent = 'Error: ' + err.message;
        feedbackEl.style.display = 'block';
      }
    });

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function evaluatePronunciation(base64Audio, correctPinyin) {
      try {
        const transcriptionRes = await fetch('https://api.openai.com/v1/audio/transcriptions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${CHATGPT_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: "whisper-1",
            language: "zh",
            response_format: "text",
            file: `data:audio/webm;base64,${base64Audio}`
          })
        });

        if (!transcriptionRes.ok) throw new Error('Transcription failed');
        const transcript = await transcriptionRes.text();

        const evalRes = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${CHATGPT_API_KEY}`
          },
          body: JSON.stringify({
            model: "gpt-4.1-mini",
            messages: [
              { role: "system", content: "You are a Mandarin pronunciation tutor. Compare the user's spoken transcription with the correct Pinyin. Provide a score from 1-10, say if it's correct, and give brief, encouraging feedback in English. Be strict but kind." },
              { role: "user", content: `Correct Pinyin: ${correctPinyin}\nUser's spoken transcription: ${transcript}` }
            ],
            max_tokens: 200
          })
        });

        const data = await evalRes.json();
        return data.choices[0].message.content;
      } catch (error) {
        console.error("Evaluation error:", error);
        return "Sorry, we couldn't evaluate your pronunciation. Please try again.";
      }
    }

    // ======================
    // HSK1  setupCanvasEve
    // ======================
    function initHSK1Characters() {
      const hsk1 = [
        { char: 'çˆ±', pinyin: 'Ã i', meaning: 'love' },
        { char: 'å…«', pinyin: 'bÄ', meaning: 'eight' },
        { char: 'çˆ¸çˆ¸', pinyin: 'bÃ  ba', meaning: 'father' },
        { char: 'æ¯å­', pinyin: 'bÄ“i zi', meaning: 'cup/glass' },
        { char: 'åŒ—äº¬', pinyin: 'BÄ›i jÄ«ng', meaning: 'Beijing' },
        { char: 'æœ¬', pinyin: 'bÄ›n', meaning: 'measure word for books' },
        { char: 'ä¸å®¢æ°”', pinyin: 'bÃ¹ kÃ¨ qi', meaning: "you're welcome" },
        { char: 'ä¸', pinyin: 'bÃ¹', meaning: 'not' },
        { char: 'èœ', pinyin: 'cÃ i', meaning: 'dish/vegetable' },
        { char: 'èŒ¶', pinyin: 'chÃ¡', meaning: 'tea' },
        { char: 'åƒ', pinyin: 'chÄ«', meaning: 'to eat' },
        { char: 'å‡ºç§Ÿè½¦', pinyin: 'chÅ« zÅ« chÄ“', meaning: 'taxi' },
        { char: 'æ‰“ç”µè¯', pinyin: 'dÇŽ diÃ n huÃ ', meaning: 'to make a phone call' },
        { char: 'å¤§', pinyin: 'dÃ ', meaning: 'big' },
        { char: 'çš„', pinyin: 'de', meaning: 'possessive particle' },
        { char: 'ç‚¹', pinyin: 'diÇŽn', meaning: 'o\'clock/a little' },
        { char: 'ç”µè„‘', pinyin: 'diÃ n nÇŽo', meaning: 'computer' },
        { char: 'ç”µè§†', pinyin: 'diÃ n shÃ¬', meaning: 'television' },
        { char: 'ç”µå½±', pinyin: 'diÃ n yÇng', meaning: 'movie' },
        { char: 'ä¸œè¥¿', pinyin: 'dÅng xi', meaning: 'thing' },
        { char: 'éƒ½', pinyin: 'dÅu', meaning: 'both/all' },
        { char: 'è¯»', pinyin: 'dÃº', meaning: 'to read' },
        { char: 'å¯¹ä¸èµ·', pinyin: 'duÃ¬ bu qÇ', meaning: 'sorry' },
        { char: 'å¤š', pinyin: 'duÅ', meaning: 'many/much' },
        { char: 'å¤šå°‘', pinyin: 'duÅ shao', meaning: 'how much/many' },
        { char: 'å„¿å­', pinyin: 'Ã©r zi', meaning: 'son' },
        { char: 'äºŒ', pinyin: 'Ã¨r', meaning: 'two' },
        { char: 'é¥­åº—', pinyin: 'fÃ n diÃ n', meaning: 'restaurant/hotel' },
        { char: 'é£žæœº', pinyin: 'fÄ“i jÄ«', meaning: 'airplane' },
        { char: 'åˆ†é’Ÿ', pinyin: 'fÄ“n zhÅng', meaning: 'minute' },
        { char: 'é«˜å…´', pinyin: 'gÄo xÃ¬ng', meaning: 'happy' },
        { char: 'ä¸ª', pinyin: 'gÃ¨', meaning: 'general measure word' },
        { char: 'å·¥ä½œ', pinyin: 'gÅng zuÃ²', meaning: 'work/job' },
        { char: 'ç‹—', pinyin: 'gÇ’u', meaning: 'dog' },
        { char: 'æ±‰è¯­', pinyin: 'HÃ n yÇ”', meaning: 'Chinese language' },
        { char: 'å¥½', pinyin: 'hÇŽo', meaning: 'good' },
        { char: 'å·', pinyin: 'hÃ o', meaning: 'number/day of month' },
        { char: 'å–', pinyin: 'hÄ“', meaning: 'to drink' },
        { char: 'å’Œ', pinyin: 'hÃ©', meaning: 'and' },
        { char: 'å¾ˆ', pinyin: 'hÄ›n', meaning: 'very' },
        { char: 'åŽé¢', pinyin: 'hÃ²u miÃ n', meaning: 'behind' },
        { char: 'å›ž', pinyin: 'huÃ­', meaning: 'to return' },
        { char: 'ä¼š', pinyin: 'huÃ¬', meaning: 'can/to know how' },
        { char: 'å‡ ', pinyin: 'jÇ', meaning: 'how many' },
        { char: 'å®¶', pinyin: 'jiÄ', meaning: 'home/family' },
        { char: 'å«', pinyin: 'jiÃ o', meaning: 'to call/to be called' },
        { char: 'ä»Šå¤©', pinyin: 'jÄ«n tiÄn', meaning: 'today' },
        { char: 'ä¹', pinyin: 'jiÇ”', meaning: 'nine' },
        { char: 'å¼€', pinyin: 'kÄi', meaning: 'to open' },
        { char: 'çœ‹', pinyin: 'kÃ n', meaning: 'to look/to watch' },
        { char: 'çœ‹è§', pinyin: 'kÃ n jiÃ n', meaning: 'to see' },
        { char: 'å—', pinyin: 'kuÃ i', meaning: 'measure word for money' },
        { char: 'æ¥', pinyin: 'lÃ¡i', meaning: 'to come' },
        { char: 'è€å¸ˆ', pinyin: 'lÇŽo shÄ«', meaning: 'teacher' },
        { char: 'äº†', pinyin: 'le', meaning: 'completed action marker' },
        { char: 'å†·', pinyin: 'lÄ›ng', meaning: 'cold' },
        { char: 'é‡Œ', pinyin: 'lÇ', meaning: 'inside' },
        { char: 'å…­', pinyin: 'liÃ¹', meaning: 'six' },
        { char: 'å¦ˆå¦ˆ', pinyin: 'mÄ ma', meaning: 'mother' },
        { char: 'å—', pinyin: 'ma', meaning: 'question particle' },
        { char: 'ä¹°', pinyin: 'mÇŽi', meaning: 'to buy' },
        { char: 'çŒ«', pinyin: 'mÄo', meaning: 'cat' },
        { char: 'æ²¡', pinyin: 'mÃ©i', meaning: 'not' },
        { char: 'æ²¡å…³ç³»', pinyin: 'mÃ©i guÄn xi', meaning: "it doesn't matter" },
        { char: 'ç±³é¥­', pinyin: 'mÇ fÃ n', meaning: 'rice' },
        { char: 'åå­—', pinyin: 'mÃ­ng zi', meaning: 'name' },
        { char: 'æ˜Žå¤©', pinyin: 'mÃ­ng tiÄn', meaning: 'tomorrow' },
        { char: 'å“ª', pinyin: 'nÇŽ', meaning: 'which' },
        { char: 'å“ªå„¿', pinyin: 'nÇŽ r', meaning: 'where' },
        { char: 'é‚£', pinyin: 'nÃ ', meaning: 'that' },
        { char: 'å‘¢', pinyin: 'ne', meaning: 'question particle' },
        { char: 'èƒ½', pinyin: 'nÃ©ng', meaning: 'can/to be able' },
        { char: 'ä½ ', pinyin: 'nÇ', meaning: 'you' },
        { char: 'å¹´', pinyin: 'niÃ¡n', meaning: 'year' },
        { char: 'å¥³å„¿', pinyin: 'nÇš Ã©r', meaning: 'daughter' },
        { char: 'æœ‹å‹', pinyin: 'pÃ©ng you', meaning: 'friend' },
        { char: 'æ¼‚äº®', pinyin: 'piÃ o liang', meaning: 'beautiful' },
        { char: 'è‹¹æžœ', pinyin: 'pÃ­ng guÇ’', meaning: 'apple' },
        { char: 'ä¸ƒ', pinyin: 'qÄ«', meaning: 'seven' },
        { char: 'å‰é¢', pinyin: 'qiÃ¡n miÃ n', meaning: 'front' },
        { char: 'é’±', pinyin: 'qiÃ¡n', meaning: 'money' },
        { char: 'è¯·', pinyin: 'qÇng', meaning: 'please' },
        { char: 'åŽ»', pinyin: 'qÃ¹', meaning: 'to go' },
        { char: 'çƒ­', pinyin: 'rÃ¨', meaning: 'hot' },
        { char: 'äºº', pinyin: 'rÃ©n', meaning: 'person' },
        { char: 'è®¤è¯†', pinyin: 'rÃ¨n shi', meaning: 'to know' },
        { char: 'æ—¥', pinyin: 'rÃ¬', meaning: 'sun/day' },
        { char: 'ä¸‰', pinyin: 'sÄn', meaning: 'three' },
        { char: 'å•†åº—', pinyin: 'shÄng diÃ n', meaning: 'shop' },
        { char: 'ä¸Š', pinyin: 'shÃ ng', meaning: 'on/above' },
        { char: 'ä¸Šåˆ', pinyin: 'shÃ ng wÇ”', meaning: 'morning' },
        { char: 'å°‘', pinyin: 'shÇŽo', meaning: 'few/little' },
        { char: 'è°', pinyin: 'shÃ©i', meaning: 'who' },
        { char: 'ä»€ä¹ˆ', pinyin: 'shÃ©n me', meaning: 'what' },
        { char: 'å', pinyin: 'shÃ­', meaning: 'ten' },
        { char: 'æ—¶å€™', pinyin: 'shÃ­ hou', meaning: 'time' },
        { char: 'æ˜¯', pinyin: 'shÃ¬', meaning: 'to be' },
        { char: 'ä¹¦', pinyin: 'shÅ«', meaning: 'book' },
        { char: 'æ°´', pinyin: 'shuÇ', meaning: 'water' },
        { char: 'æ°´æžœ', pinyin: 'shuÇ guÇ’', meaning: 'fruit' },
        { char: 'ç¡è§‰', pinyin: 'shuÃ¬ jiÃ o', meaning: 'to sleep' },
        { char: 'è¯´', pinyin: 'shuÅ', meaning: 'to speak' },
        { char: 'å››', pinyin: 'sÃ¬', meaning: 'four' },
        { char: 'å²', pinyin: 'suÃ¬', meaning: 'year (of age)' },
        { char: 'ä»–', pinyin: 'tÄ', meaning: 'he/him' },
        { char: 'å¥¹', pinyin: 'tÄ', meaning: 'she/her' },
        { char: 'å¤ª', pinyin: 'tÃ i', meaning: 'too' },
        { char: 'å¤©æ°”', pinyin: 'tiÄn qÃ¬', meaning: 'weather' },
        { char: 'å¬', pinyin: 'tÄ«ng', meaning: 'to listen' },
        { char: 'åŒå­¦', pinyin: 'tÃ³ng xuÃ©', meaning: 'classmate' },
        { char: 'å–‚', pinyin: 'wÃ¨i', meaning: 'hello (on phone)' },
        { char: 'æˆ‘', pinyin: 'wÇ’', meaning: 'I/me' },
        { char: 'æˆ‘ä»¬', pinyin: 'wÇ’ men', meaning: 'we/us' },
        { char: 'äº”', pinyin: 'wÇ”', meaning: 'five' },
        { char: 'å–œæ¬¢', pinyin: 'xÇ huan', meaning: 'to like' },
        { char: 'ä¸‹', pinyin: 'xiÃ ', meaning: 'under/below' },
        { char: 'ä¸‹åˆ', pinyin: 'xiÃ  wÇ”', meaning: 'afternoon' },
        { char: 'ä¸‹é›¨', pinyin: 'xiÃ  yÇ”', meaning: 'to rain' },
        { char: 'å…ˆç”Ÿ', pinyin: 'xiÄn sheng', meaning: 'Mr.' },
        { char: 'çŽ°åœ¨', pinyin: 'xiÃ n zÃ i', meaning: 'now' },
        { char: 'æƒ³', pinyin: 'xiÇŽng', meaning: 'to want/to think' },
        { char: 'å°', pinyin: 'xiÇŽo', meaning: 'small' },
        { char: 'å°å§', pinyin: 'xiÇŽo jiÄ›', meaning: 'Miss' },
        { char: 'äº›', pinyin: 'xiÄ“', meaning: 'some' },
        { char: 'å†™', pinyin: 'xiÄ›', meaning: 'to write' },
        { char: 'è°¢è°¢', pinyin: 'xiÃ¨ xie', meaning: 'thank you' },
        { char: 'æ˜ŸæœŸ', pinyin: 'xÄ«ng qÄ«', meaning: 'week' },
        { char: 'å­¦ç”Ÿ', pinyin: 'xuÃ© sheng', meaning: 'student' },
        { char: 'å­¦ä¹ ', pinyin: 'xuÃ© xÃ­', meaning: 'to study' },
        { char: 'å­¦æ ¡', pinyin: 'xuÃ© xiÃ o', meaning: 'school' },
        { char: 'ä¸€', pinyin: 'yÄ«', meaning: 'one' },
        { char: 'è¡£æœ', pinyin: 'yÄ« fu', meaning: 'clothes' },
        { char: 'åŒ»ç”Ÿ', pinyin: 'yÄ« shÄ“ng', meaning: 'doctor' },
        { char: 'åŒ»é™¢', pinyin: 'yÄ« yuÃ n', meaning: 'hospital' },
        { char: 'æ¤…å­', pinyin: 'yÇ zi', meaning: 'chair' },
        { char: 'æœ‰', pinyin: 'yÇ’u', meaning: 'to have' },
        { char: 'æœˆ', pinyin: 'yuÃ¨', meaning: 'month/moon' },
        { char: 'åœ¨', pinyin: 'zÃ i', meaning: 'at/in' },
        { char: 'å†è§', pinyin: 'zÃ i jiÃ n', meaning: 'goodbye' },
        { char: 'æ€Žä¹ˆ', pinyin: 'zÄ›n me', meaning: 'how' },
        { char: 'æ€Žä¹ˆæ ·', pinyin: 'zÄ›n me yÃ ng', meaning: 'how about' },
        { char: 'è¿™', pinyin: 'zhÃ¨', meaning: 'this' },
        { char: 'ä¸­å›½', pinyin: 'ZhÅng guÃ³', meaning: 'China' },
        { char: 'ä¸­åˆ', pinyin: 'zhÅng wÇ”', meaning: 'noon' },
        { char: 'ä½', pinyin: 'zhÃ¹', meaning: 'to live' },
        { char: 'æ¡Œå­', pinyin: 'zhuÅ zi', meaning: 'table' },
        { char: 'å­—', pinyin: 'zÃ¬', meaning: 'character' },
        { char: 'æ˜¨å¤©', pinyin: 'zuÃ³ tiÄn', meaning: 'yesterday' },
        { char: 'å', pinyin: 'zuÃ²', meaning: 'to sit' },
        { char: 'åš', pinyin: 'zuÃ²', meaning: 'to do' }
      ];

      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = 'HSK1';
      toggleBtn.style.position = 'fixed';
      toggleBtn.style.bottom = '20px';
      toggleBtn.style.right = '20px';
      toggleBtn.style.zIndex = '1000';
      toggleBtn.style.padding = '10px';
      toggleBtn.style.borderRadius = '8px';
      toggleBtn.style.background = '#2563eb';
      toggleBtn.style.color = 'white';
      toggleBtn.style.border = 'none';
      toggleBtn.style.cursor = 'pointer';
      toggleBtn.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
      toggleBtn.style.fontSize = '14px';

      const container = document.createElement('div');
      container.className = 'hsk1-palette';
      container.style.position = 'fixed';
      container.style.bottom = '70px';
      container.style.right = '20px';
      container.style.background = 'white';
      container.style.padding = '10px';
      container.style.borderRadius = '8px';
      container.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
      container.style.zIndex = '999';
      container.style.maxHeight = '300px';
      container.style.overflowY = 'auto';
      container.style.display = 'none';

      hsk1.forEach(item => {
        const charBtn = document.createElement('button');
        charBtn.textContent = item.char;
        charBtn.style.fontSize = '24px';
        charBtn.style.margin = '5px';
        charBtn.style.padding = '5px 10px';
        charBtn.style.border = 'none';
        charBtn.style.borderRadius = '4px';
        charBtn.style.background = '#f3f4f6';
        charBtn.style.cursor = 'pointer';
        charBtn.onclick = () => {
          drawTextOnCanvas(document.getElementById('character-canvas'), item.char);
          document.getElementById('pinyin-input').value = item.pinyin;
          document.getElementById('meaning-input').value = item.meaning;
        };
        container.appendChild(charBtn);
      });

      toggleBtn.onclick = () => {
        const isHidden = container.style.display === 'none';
        container.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? 'Hide' : 'HSK1';
      };

      document.body.appendChild(container);
      document.body.appendChild(toggleBtn);
    }

    function setupQuizToggles() {
      const toggleQuizBtn = document.getElementById('start-quiz-btn');
      const quizSection = document.querySelector('.quiz-section');
      toggleQuizBtn.addEventListener('click', () => {
        const isHidden = quizSection.style.display === 'none';
        quizSection.style.display = isHidden ? 'block' : 'none';
        toggleQuizBtn.textContent = isHidden ? 'Hide Character Quiz' : 'Start Quiz';
      });

      const toggleSentenceBtn = document.getElementById('start-sentence-quiz-btn');
      const sentenceSection = document.querySelector('.sentence-quiz-section');
      toggleSentenceBtn.addEventListener('click', () => {
        const isHidden = sentenceSection.style.display === 'none';
        sentenceSection.style.display = isHidden ? 'block' : 'none';
        toggleSentenceBtn.textContent = isHidden ? 'Hide Sentence Quiz' : 'Start Sentence Quiz';
      });
    }

    

    async function handlePaste(e) {
      e.preventDefault();
      const canvas = e.target;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const text = e.clipboardData.getData('text');
      if (text) {
        drawTextOnCanvas(canvas, text);
        return;
      }

      const items = e.clipboardData.items;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf('image') !== -1) {
          const blob = items[i].getAsFile();
          const img = await createImageBitmap(blob);
          drawImageOnCanvas(canvas, img);
          return;
        }
      }
    }

    function drawTextOnCanvas(canvas, text) {
      const ctx = canvas.getContext('2d');
      let fontSize = Math.min(canvas.width/1.5, canvas.height/1.5);
      ctx.font = `bold ${fontSize}px 'Noto Sans SC', sans-serif`;
      const textMetrics = ctx.measureText(text);
      while (textMetrics.width > canvas.width || fontSize > canvas.height) {
        fontSize -= 2;
        ctx.font = `bold ${fontSize}px 'Noto Sans SC', sans-serif`;
        textMetrics.width = ctx.measureText(text).width;
      }
      const x = (canvas.width - textMetrics.width) / 2;
      const y = (canvas.height + fontSize) / 2.5;
      ctx.fillStyle = '#000000';
      ctx.fillText(text, x, y);
    }

    function drawImageOnCanvas(canvas, img) {
      const ctx = canvas.getContext('2d');
      const ratio = Math.min(canvas.width / img.width, canvas.height / img.height);
      const width = img.width * ratio;
      const height = img.height * ratio;
      const x = (canvas.width - width) / 2;
      const y = (canvas.height - height) / 2;
      ctx.drawImage(img, x, y, width, height);
    }

// ======================
// Core Drawing Functions
// ======================

function initCanvases() {
  const canvases = [
    { id: 'character-canvas', bgColor: '#ffffff' },
    { id: 'mnemonic-canvas', bgColor: '#ffffff' }
  ];
  canvases.forEach(canvasInfo => {
    const canvas = document.getElementById(canvasInfo.id);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();

    // Set internal size to match display Ã— DPI
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    // Scale context to match CSS pixels
    ctx.scale(dpr, dpr);

    // Drawing style
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4; // Thicker stroke

    // Background setupCanvasEvents
    ctx.fillStyle = canvasInfo.bgColor;
    ctx.fillRect(0, 0, rect.width, rect.height);
  });
}


function clearCanvas(canvasId) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  ctx.clearRect(0, 0, rect.width * dpr, rect.height * dpr);
  
  // Restore background
  const bgColor = canvasId === 'sentence-canvas' ? '#f8f9fa' : '#ffffff';
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, rect.width * dpr, rect.height * dpr);
}
    // ======================
    // Character  etupTempCanv
    // ======================

    function setupTempCanvas(canvas) {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);

  ctx.fillStyle = canvas.classList.contains('sentence-canvas') ? '#f8f9fa' : '#ffffff';
  ctx.fillRect(0, 0, rect.width, rect.height);
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 4; // Thicker
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  let isDrawing = false;
  let lastX = 0;
  let lastY = 0;

  canvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    lastX = (e.clientX - rect.left) * dpr;
    lastY = (e.clientY - rect.top) * dpr;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * dpr;
    const y = (e.clientY - rect.top) * dpr;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    [lastX, lastY] = [x, y];
  });

  ['mouseup', 'mouseout'].forEach(event => {
    canvas.addEventListener(event, () => isDrawing = false);
  });
}
//setStrokeWidth
    async function loadCharacters() {
      const container = document.getElementById('entries-container');
      container.innerHTML = '<p>Loading characters...</p>';
      try {
        const { data:characters, error } = await window.supabase
          .from('chinese_characters')
          .select('*')
          .order('created_at', { ascending: false });
        if (error) throw error;
        if (!characters || characters.length === 0) {
          container.innerHTML = '<p>No characters found. Add your first character above.</p>';
          return;
        }
        container.innerHTML = '';
        characters.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = 'entry-card';
          entryEl.innerHTML = `
            <div class="entry-header">
              <div class="entry-pinyin">${entry.pinyin}</div>
            </div>
            <div class="entry-meta">
              <p><strong>Meaning:</strong> ${entry.meaning}</p>
              <p><strong>Hint:</strong> ${entry.hint}</p>
            </div>
            <div class="image-grid">
              <div>
                <p><strong>Character Drawing:</strong></p>
                <img src="${entry.character}" class="entry-image">
              </div>
              <div>
                <p><strong>Mnemonic Drawing:</strong></p>
                <img src="${entry.mnemonic}" class="entry-image">
              </div>
            </div>
            <div class="entry-actions">
              <button class="btn btn-danger" onclick="deleteCharacter('${entry.id}')">Delete</button>
            </div>
          `;
          container.appendChild(entryEl);
        });
      } catch (error) {
        console.error('Error loading characters:', error);
        container.innerHTML = `<p>Failed to load characters.</p>`;
      }
    }
//characterCanvas
    async function saveCharacter() {
  const pinyin = document.getElementById('pinyin-input').value.trim();
  const meaning = document.getElementById('meaning-input').value.trim();
  const hint = document.getElementById('hint-input').value.trim();

  if (!pinyin || !meaning || !hint) {
    alert('Please enter pinyin, meaning, and hint');
    return;
  }

  const button = document.getElementById('upload-button');
  button.disabled = true;
  button.innerHTML = '<span class="loading"></span> Saving...';

  try {
    // Upload both images in parallel
    const [charImageUrl, mnemonicImageUrl] = await Promise.all([
      uploadToCloudinary('characterCanvas', `char-${Date.now()}`),
      uploadToCloudinary('mnemonicCanvas', `mnemonic-${Date.now()}`)
    ]);

    // Save to Supabase
    const { data, error } = await window.supabase
      .from('chinese_characters')
      .insert([{
        pinyin,
        meaning,
        hint,
        character: charImageUrl,
        mnemonic: mnemonicImageUrl,
        created_at: new Date().toISOString()
      }])
      .select();

    if (error) throw error;

    // Reset form
    document.getElementById('pinyin-input').value = '';
    document.getElementById('meaning-input').value = '';
    document.getElementById('hint-input').value = '';
    clearCanvas('characterCanvas');
    clearCanvas('mnemonicCanvas');

    // Reload characters
    loadCharacters();

    button.innerHTML = '<span class="success-icon">âœ“</span> Saved';
    setTimeout(() => {
      button.innerHTML = 'Save Character';
      button.disabled = false;
    }, 2000);
  } catch (error) {
    console.error('Save failed:', error);
    alert(`Save failed: ${error.message}`);
    button.innerHTML = 'Save Character';
    button.disabled = false;
  }
}
//upload-button
    async function deleteCharacter(id) {
      if (!confirm('Delete this character?')) return;
      try {
        const { error } = await window.supabase
          .from('chinese_characters')
          .delete()
          .eq('id', id);
        if (error) throw error;
        loadCharacters();
      } catch (error) {
        console.error('Delete failed:', error);
        alert('Failed to delete');
      }
    }

    // ======================
    // Quiz System  .addEventListener DOMContentLoaded
    // ======================
    function initQuizSystem() {
      document.getElementById('start-quiz-btn').addEventListener('click', toggleCharacterQuiz);
      document.getElementById('check-answers-btn').addEventListener('click', checkAnswers);
    }

    function initSentenceQuiz() {
      document.getElementById('start-sentence-quiz-btn').addEventListener('click', toggleSentenceQuiz);
    }

    function startQuiz() {
      const quizSection = document.querySelector('.quiz-section');
      const entriesContainer = document.getElementById('entries-container');
      entriesContainer.style.display = 'none';
      quizSection.style.display = 'block';
      quizEntries = Array.from(document.querySelectorAll('.entry-card')).map(card => ({
        pinyin: card.querySelector('.entry-pinyin').textContent,
        meaning: card.querySelector('.entry-meta p:first-child').textContent.replace('Meaning:', '').trim(),
        hint: card.querySelector('.entry-meta p:last-child').textContent.replace('Hint:', '').trim(),
        character: card.querySelector('.image-grid div:first-child img').src,
        mnemonic: card.querySelector('.image-grid div:last-child img').src
      }));
      quizEntries = shuffleArray(quizEntries);
      renderQuizForms();
    }

    function renderQuizForms() {
      const container = document.getElementById('quiz-container');
      container.innerHTML = '';
      quizEntries.forEach((entry, index) => {
        const form = document.createElement('div');
        form.className = 'quiz-form';
        form.dataset.index = index;
        const properties = ['pinyin', 'meaning', 'hint', 'character', 'mnemonic'];
        const shuffledProperties = shuffleArray([...properties]);
        const revealedProperty = shuffledProperties[0];
        form.dataset.revealed = revealedProperty;
        const revealedDiv = document.createElement('div');
        revealedDiv.className = 'revealed';
        revealedDiv.innerHTML = `<strong>${propertyToLabel(revealedProperty)}:</strong> `;
        if (revealedProperty === 'character' || revealedProperty === 'mnemonic') {
          const img = document.createElement('img');
          img.src = entry[revealedProperty];
          img.style.maxHeight = '100px';
          revealedDiv.appendChild(img);
        } else {
          revealedDiv.innerHTML += entry[revealedProperty];
        }
        form.appendChild(revealedDiv);
        
        // Add hint reveal button for each form
        const hintButton = document.createElement('button');
        hintButton.type = 'button';
        hintButton.className = 'btn btn-secondary hint-reveal-btn';
        hintButton.textContent = 'ðŸ’¡ Show Hint';
        hintButton.style.marginBottom = '16px';
        hintButton.onclick = () => {
          const hintText = entry.hint;
          if (hintButton.textContent === 'ðŸ’¡ Show Hint') {
            hintButton.textContent = 'ðŸ’¡ Hide Hint';
            const hintDiv = document.createElement('div');
            hintDiv.className = 'hint-display';
            hintDiv.style.cssText = 'background: var(--gray-100); padding: 12px; border-radius: var(--radius); margin: 8px 0; border-left: 4px solid var(--secondary);';
            hintDiv.innerHTML = `<strong>Hint:</strong> ${hintText}`;
            hintButton.parentNode.insertBefore(hintDiv, hintButton.nextSibling);
          } else {
            hintButton.textContent = 'ðŸ’¡ Hide Hint';
            const hintDiv = hintButton.parentNode.querySelector('.hint-display');
            if (hintDiv) hintDiv.remove();
          }
        };
        form.appendChild(hintButton);
        
        shuffledProperties.slice(1).forEach(prop => {
          const group = document.createElement('div');
          group.className = 'hidden-input';
          const label = document.createElement('label');
          label.textContent = `Enter ${propertyToLabel(prop)}:`;
          group.appendChild(label);
          if (prop === 'character' || prop === 'mnemonic') {
            const canvas = document.createElement('canvas');
            canvas.width = 350;
            canvas.height = 350;
            canvas.dataset.property = prop;
            group.appendChild(canvas);
            setupTempCanvas(canvas);
          } else {
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = `Enter ${propertyToLabel(prop)}`;
            input.dataset.property = prop;
            group.appendChild(input);
          }
          form.appendChild(group);
        });
        container.appendChild(form);
      });
    }

    function checkAnswers() {
      const forms = document.querySelectorAll('.quiz-form');
      let allCorrect = true;
      forms.forEach(form => {
        const revealedProp = form.dataset.revealed;
        const entryIndex = form.dataset.index;
        const correctEntry = quizEntries[entryIndex];
        const feedback = document.createElement('div');
        feedback.className = 'feedback';
        let formCorrect = true;
        const inputs = form.querySelectorAll('[data-property]');
        inputs.forEach(input => {
          const prop = input.dataset.property;
          let userValue;
          if (input.tagName === 'CANVAS') {
            const ctx = input.getContext('2d');
            const imageData = ctx.getImageData(0, 0, input.width, input.height).data;
            let isEmpty = true;
            for (let i = 0; i < imageData.length; i += 4) {
              if (imageData[i] !== 255) {
                isEmpty = false;
                break;
              }
            }
            if (isEmpty) {
              formCorrect = false;
              input.style.border = '2px solid #ff4444';
            } else {
              input.style.border = '2px solid #00C851';
            }
          } else {
            userValue = input.value.trim().toLowerCase();
            const correctValue = String(correctEntry[prop]).toLowerCase();
            if (userValue !== correctValue) {
              formCorrect = false;
              input.style.border = '2px solid #ff4444';
            } else {
              input.style.border = '2px solid #00C851';
            }
          }
        });
        if (!formCorrect) {
          allCorrect = false;
          feedback.innerHTML = `Correct: ${Object.entries(correctEntry)
            .filter(([key]) => key !== revealedProp)
            .map(([key, val]) => `${propertyToLabel(key)}: ${key.includes('character') || key.includes('mnemonic') ? '(see image)' : val}`)
            .join(', ')}`;
          feedback.style.color = '#ff4444';
        } else {
          feedback.innerHTML = 'All correct!';
          feedback.style.color = '#00C851';
        }
        form.appendChild(feedback);
      });
      if (allCorrect) {
        setTimeout(() => alert('All correct!'), 300);
      }
    }

    function toggleCharacterQuiz() {
      const quizSection = document.querySelector('.quiz-section');
      const entriesContainer = document.getElementById('entries-container');
      const button = document.getElementById('start-quiz-btn');
      const isHidden = quizSection.style.display === 'none';
      if (isHidden) {
        entriesContainer.style.display = 'none';
        quizSection.style.display = 'block';
        button.textContent = 'Hide Character Quiz';
        startQuiz();
      } else {
        quizSection.style.display = 'none';
        entriesContainer.style.display = 'grid';
        button.textContent = 'Start Quiz';
      }
    }

    function toggleSentenceQuiz() {
      const sentenceSection = document.querySelector('.sentence-quiz-section');
      const button = document.getElementById('start-sentence-quiz-btn');
      const isHidden = sentenceSection.style.display === 'none';
      if (isHidden) {
        sentenceSection.style.display = 'block';
        button.textContent = 'Hide Sentence Quiz';
        startSentenceQuiz();
      } else {
        sentenceSection.style.display = 'none';
        button.textContent = 'Start Sentence Quiz';
      }
    }

    async function startSentenceQuiz() {
      const length = parseInt(document.getElementById('sentence-length').value);
      const container = document.getElementById('sentence-quiz-container');
      container.innerHTML = '<p>Generating sentences...</p>';
      const { data: words, error } = await window.supabase
        .from('chinese_characters')
        .select('pinyin, meaning, hint');
      if (error || !words || words.length < length) {
        container.innerHTML = `<p>Need at least ${length} words</p>`;
        return;
      }
      sentenceQuizEntries = await generateQuizSentences(words, length);
      renderSentenceQuizForms();
      document.querySelector('.sentence-quiz-section').style.display = 'block';
    }

    async function generateQuizSentences(words, length) {
      const prompt = `Generate ${length} simple Chinese sentences using exactly ${length} of the provided words.
      Word list:
      ${words.map(w => `${w.pinyin} (${w.pinyin}: ${w.meaning})`).join('\n')}
      For each sentence, provide:
      1. Chinese sentence
      2. Pinyin (with tones)
      3. Literal English translation
      4. Natural English translation
      Return JSON:
      [{"chinese":"...","pinyin":"...","literal":"...","natural":"..."}]`;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${CHATGPT_API_KEY}`
          },
          body: JSON.stringify({
            model: "gpt-4.1-mini",
            messages: [{ role: "user", content: prompt }],
            response_format: { type: "json_object" },
            max_tokens: 2000
          })
        });
        const data = await response.json();
        return JSON.parse(data.choices[0].message.content);
      } catch (error) {
        console.error("Error generating sentences:", error);
        return [];
      }
    }

    function renderSentenceQuizForms() {
      const container = document.getElementById('sentence-quiz-container');
      container.innerHTML = '';
      sentenceQuizEntries.forEach((sentence, index) => {
        const form = document.createElement('div');
        form.className = 'sentence-quiz-form';
        form.dataset.index = index;
        const properties = ['chinese', 'pinyin', 'literal', 'natural'];
        const shuffledProperties = shuffleArray([...properties]);
        const revealedProperty = shuffledProperties[0];
        form.dataset.revealed = revealedProperty;
        const revealedDiv = document.createElement('div');
        revealedDiv.className = 'revealed';
        revealedDiv.innerHTML = `<strong>${propertyToLabel(revealedProperty)}:</strong> ${sentence[revealedProperty]}`;
        // Add play button for Chinese text
        if (revealedProperty === 'chinese') {
          const playBtn = document.createElement('button');
          playBtn.type = 'button';
          playBtn.className = 'btn btn-secondary';
          playBtn.textContent = 'ðŸ”Š';
          playBtn.title = 'Play pronunciation';
          playBtn.style.marginLeft = '8px';
          playBtn.onclick = () => playChinese(sentence.chinese, sentence.pinyin);
          revealedDiv.appendChild(playBtn);
        }
        form.appendChild(revealedDiv);
        shuffledProperties.slice(1).forEach(prop => {
          const group = document.createElement('div');
          group.className = 'hidden-input';
          const label = document.createElement('label');
          label.textContent = `Enter ${propertyToLabel(prop)}:`;
          group.appendChild(label);
          if (prop === 'chinese') {
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 200;
            canvas.className = 'sentence-canvas';
            canvas.dataset.property = prop;
            group.appendChild(canvas);
            setupTempCanvas(canvas);
          } else {
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = `Enter ${propertyToLabel(prop)}`;
            input.dataset.property = prop;
            group.appendChild(input);
          }
          const checkBtn = document.createElement('button');
          checkBtn.className = 'btn btn-secondary';
          checkBtn.textContent = 'Check Answer';
          checkBtn.onclick = () => checkSentenceAnswer(sentence, prop, group);
          group.appendChild(checkBtn);
          const feedback = document.createElement('div');
          feedback.className = 'feedback';
          group.appendChild(feedback);
          form.appendChild(group);
        });
        container.appendChild(form);
      });
    }

    async function checkSentenceAnswer(correctSentence, property, group) {
      const input = group.querySelector('[data-property]');
      const feedback = group.querySelector('.feedback');
      feedback.innerHTML = '<div class="verifying">Verifying...</div>';
      try {
        let result;
        if (property === 'chinese') {
          result = await evaluateChineseHandwriting(input, correctSentence.chinese);
        } else {
          const userAnswer = input.value.trim().toLowerCase();
          const correctAnswer = String(correctSentence[property]).toLowerCase();
          const isCorrect = userAnswer === correctAnswer;
          result = {
            score: isCorrect ? 10 : 0,
            correct: isCorrect,
            feedback: isCorrect ? 'Correct!' : `Incorrect. Correct: ${correctSentence[property]}`,
            incorrectChars: []
          };
        }
        feedback.innerHTML = `
          <div class="result ${result.correct ? 'correct' : 'incorrect'}">
            <p>Score: ${result.score}/10</p>
            <p>${result.feedback}</p>
            ${result.incorrectChars?.length ? `<p>Incorrect: ${result.incorrectChars.join(', ')}</p>` : ''}
          </div>
        `;
        input.style.border = result.correct ? '2px solid #00C851' : '2px solid #ff4444';
      } catch (error) {
        console.error("Verification failed:", error);
        feedback.innerHTML = '<div class="error">Failed. Try again.</div>';
      }
    }

    async function evaluateChineseHandwriting(canvas, correctText) {
      const base64Image = canvas.toDataURL('image/jpeg', 0.8);
      const prompt = `Compare this handwriting with "${correctText}". Return JSON: {score:0-10, correct:bool, feedback:str, incorrectChars:[]}`;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${CHATGPT_API_KEY}`
          },
          body: JSON.stringify({
            model: "gpt-4.1-mini",
            messages: [{
              role: "user",
              content: [
                { type: "text", text: prompt },
                { type: "image_url", image_url: { url: base64Image, detail: "high" } }
              ]
            }],
            response_format: { type: "json_object" },
            max_tokens: 500
          })
        });
        const data = await response.json();
        return JSON.parse(data.choices[0].message.content);
      } catch (error) {
        console.error("Evaluation failed:", error);
        return { score: 0, correct: false, feedback: "Failed", incorrectChars: [] };
      }
    }

    // ======================
    // Utilities
    // ======================
    function propertyToLabel(prop) {
      const labels = {
        pinyin: 'Pinyin',
        meaning: 'Meaning',
        hint: 'Hint',
        character: 'Character Drawing',
        mnemonic: 'Mnemonic Drawing',
        chinese: 'Chinese Characters',
        literal: 'Literal Translation',
        natural: 'Natural Translation'
      };
      return labels[prop] || prop;
    }

    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

async function uploadToCloudinary(canvasId, publicId) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) throw new Error('Canvas not found');
  
  return new Promise((resolve, reject) => {
    canvas.toBlob(async (blob) => {
      try {
        // Convert blob to base64 for backend processing
        const reader = new FileReader();
        reader.onload = async () => {
          const base64Data = reader.result;
          
          // For now, return the base64 data - the backend will handle Cloudinary upload
          // This will be processed when saving the character
          resolve(base64Data);
        };
        reader.readAsDataURL(blob);
      } catch (err) {
        console.error('Upload failed:', err);
        reject(err);
      }
    }, 'image/jpeg', 0.8);
  });
}
//saveCharacter
function setupCanvasEvents() {
  const canvases = [
    { id: 'characterCanvas', clearId: 'clear-character' },
    { id: 'mnemonicCanvas', clearId: 'clear-mnemonic' }
  ];

  canvases.forEach(function(canvasInfo) {
    const canvas = document.getElementById(canvasInfo.id);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // Initialize canvas
    function initCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      
      // Set internal size (accounting for DPR)
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      
      // Set display size (CSS pixels)
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      
      // Scale context
      ctx.scale(dpr, dpr);
      
      // Set drawing styles
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Clear canvas
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Get accurate position (fixed version)
    function getPosition(e) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      
      // Calculate the scaling factors
      const scaleX = canvas.width / (rect.width * dpr);
      const scaleY = canvas.height / (rect.height * dpr);
      
      // Return coordinates adjusted for scaling
      return [
        (e.clientX - rect.left) * scaleX,
        (e.clientY - rect.top) * scaleY
      ];
    }

    // Start drawing
    function startDrawing(e) {
      isDrawing = true;
      var pos = getPosition(e);
      lastX = pos[0];
      lastY = pos[1];
    }

    // Draw line
    function draw(e) {
      if (!isDrawing) return;
      var pos = getPosition(e);
      var x = pos[0];
      var y = pos[1];
      
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      
      lastX = x;
      lastY = y;
    }

    // Stop drawing
    function endDrawing() {
      isDrawing = false;
    }

    // Initialize
    initCanvas();
    
    // Handle window resize
    window.addEventListener('resize', initCanvas);
    
    // Mouse events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDrawing);
    canvas.addEventListener('mouseout', endDrawing);
    
// In your setupCanvasEvents function:
canvas.addEventListener('touchstart', function(e) {
  if (e.cancelable) {
    e.preventDefault();
  }
  startDrawing(e.touches[0]);
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  if (e.cancelable) {
    e.preventDefault();
  }
  draw(e.touches[0]);
}, { passive: false });
    

    
    canvas.addEventListener('touchend', endDrawing);

    // Clear  uploadToCloudinary
    document.getElementById(canvasInfo.clearId).addEventListener('click', function() {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    });
  });
}
 //getPosition   
    window.deleteCharacter = deleteCharacter;
    window.loadCharacters = loadCharacters;
  </script>
</body>
</html>